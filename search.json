[{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/CLAUDE.html","id":"temporary-files","dir":"","previous_headings":"","what":"Temporary Files","title":"Claude Code Instructions","text":"temporary files created planning, testing, scratch work, transient purpose must placed scratch/ directory project root.","code":""},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/CLAUDE.html","id":"iteration-use-purrr-not-base-r-applyloops","dir":"","previous_headings":"Coding Conventions","what":"Iteration: Use purrr, not base R apply/loops","title":"Claude Code Instructions","text":"Use map(), map_chr(), map_dbl(), map_lgl(), map_int() instead lapply(), vapply(), sapply() Use walk(), iwalk(), imap() side-effect iteration instead loops Exception: loops iterating columns (e.g., setting data.table columns reference) acceptable Prefer specific typed variant return type known (map_chr map character results, etc.)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/CLAUDE.html","id":"strings-use-stringr-not-base-r-string-functions","dir":"","previous_headings":"Coding Conventions","what":"Strings: Use stringr, not base R string functions","title":"Claude Code Instructions","text":"str_detect() instead grepl() str_subset() instead grep(..., value = TRUE) str_replace() / str_replace_all() instead sub() / gsub() str_sub() instead substr() / substring() str_extract() / str_extract_all() instead regmatches() + regexpr() / gregexpr() str_locate() / str_locate_all() instead regexpr() / gregexpr() positions str_c() instead paste0() / paste() str_glue() instead sprintf() string interpolation str_length() instead nchar() str_trim() instead trimws() str_split() instead strsplit() (use fixed() wrapper fixed patterns) str_to_lower() / str_to_upper() instead tolower() / toupper() Exception: formatC() format() numeric formatting remain -(stringr equivalent)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Custom Analysis Layers","text":"tplyr2 provides three built-layer types – group_count(), group_desc(), group_shift() – cover clinical table patterns. sometimes need computations fit neatly : geometric means, custom ratios, composite endpoints, analysis need full control calculation presentation. group_analyze() fills gap. lets supply function compute summary statistics group, preserving tplyr2’s column-based layout, formatting, ordering infrastructure. vignette covers operating modes: format strings mode (tplyr2 handles formatting) pre-formatted mode (function returns display-ready strings).","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"the-analyze_fn-contract","dir":"Articles","previous_headings":"","what":"The analyze_fn Contract","title":"Custom Analysis Layers","text":"Every group_analyze() layer requires analyze_fn – function tplyr2 calls combination column variables. function signature : .data data.frame subset current group .target_var character string naming target variable. function returns determines two modes tplyr2 uses process results.","code":"function(.data, .target_var) { ... }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"format-strings-mode","dir":"Articles","previous_headings":"","what":"Format Strings Mode","title":"Custom Analysis Layers","text":"format strings mode, analyze_fn returns single-row data.frame named numeric columns. supply format_strings layer_settings() control statistic formatted labeled output. mode useful want tplyr2’s formatting system (alignment, decimal precision, parenthesis hugging) handle display. example computing geometric mean geometric standard deviation urate lab values treatment group: things note: names format_strings list (“Geometric Mean”, “Geometric SD”) become row labels output, just like group_desc() format strings. f_str() references column name data.frame function returns. \"xxx.xx\" template means three integer digits two decimal places. = \"Urate (umol/L)\" string match column data, tplyr2 treats text label appears outer row label. useful labeling blocks custom statistics. argument filters data function called.","code":"geo_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   pos_vals <- vals[!is.na(vals) & vals > 0]   data.frame(     geo_mean = exp(mean(log(pos_vals))),     geo_sd   = exp(sd(log(pos_vals)))   ) }  spec <- tplyr_spec(   cols = \"TRTP\",   layers = tplyr_layers(     group_analyze(\"AVAL\",       by = \"Urate (umol/L)\",       where = AVISIT == \"Baseline\",       analyze_fn = geo_fn,       settings = layer_settings(         format_strings = list(           \"Geometric Mean\" = f_str(\"xxx.xx\", \"geo_mean\"),           \"Geometric SD\"   = f_str(\"xxx.xx\", \"geo_sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"multiple-statistics-per-row","dir":"Articles","previous_headings":"Format Strings Mode","what":"Multiple Statistics Per Row","title":"Custom Analysis Layers","text":"Format strings can combine multiple statistics single row, just group_desc(). compute mean standard deviation one row, median another: produces style output get group_desc(), computed function.","code":"summary_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   vals <- vals[!is.na(vals)]   data.frame(     n      = length(vals),     mean   = mean(vals),     sd     = sd(vals),     median = median(vals)   ) }  spec <- tplyr_spec(   cols = \"TRTP\",   layers = tplyr_layers(     group_analyze(\"AVAL\",       by = \"Urate (umol/L)\",       where = AVISIT == \"Baseline\",       analyze_fn = summary_fn,       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xx\", \"n\"),           \"Mean (SD)\" = f_str(\"xxx.x (xxx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xxx.xx\", \"median\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"pre-formatted-mode","dir":"Articles","previous_headings":"","what":"Pre-Formatted Mode","title":"Custom Analysis Layers","text":"Sometimes want complete control output strings – example, formatting logic complex, need conditional formatting, output map cleanly f_str() system. pre-formatted mode, analyze_fn returns data.frame two columns: row_label (character) formatted (character). format_strings needed case. value row_label column becomes row label output. corresponding formatted value placed appropriate result column. mode gives full control, also means responsible alignment spacing – tplyr2 pad round strings .","code":"range_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   vals <- vals[!is.na(vals)]   data.frame(     row_label = c(\"Range\", \"Ratio (Max/Min)\"),     formatted = c(       sprintf(\"%.1f - %.1f\", min(vals), max(vals)),       sprintf(\"%.2f\", max(vals) / min(vals))     )   ) }  spec <- tplyr_spec(   cols = \"TRTP\",   layers = tplyr_layers(     group_analyze(\"AVAL\",       by = \"Urate (umol/L)\",       where = AVISIT == \"Baseline\",       analyze_fn = range_fn     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"integration-with-by-variables","dir":"Articles","previous_headings":"","what":"Integration with by Variables","title":"Custom Analysis Layers","text":"parameter group_analyze() works way layer types. Strings match column names data treated grouping variables; strings match treated text labels. analyze_fn called unique combination column variables data variables. compute statistics separately visit: output, rowlabel1 contains text label “Urate (umol/L)”, rowlabel2 contains visit values data, rowlabel3 contains row labels function output. parameter can mix labels data variables freely – tplyr2 sorts automatically.","code":"mean_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   vals <- vals[!is.na(vals)]   data.frame(     row_label = \"Mean (SD)\",     formatted = sprintf(\"%.1f (%.2f)\", mean(vals), sd(vals))   ) }  spec <- tplyr_spec(   cols = \"TRTP\",   layers = tplyr_layers(     group_analyze(\"AVAL\",       by = c(\"Urate (umol/L)\", \"AVISIT\"),       where = AVISIT %in% c(\"Baseline\", \"Week 4\", \"Week 8\"),       analyze_fn = mean_fn     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"combining-with-other-layers","dir":"Articles","previous_headings":"","what":"Combining with Other Layers","title":"Custom Analysis Layers","text":"group_analyze() layer integrates naturally multi-layer spec alongside group_count(), group_desc(), group_shift(). layer gets ord_layer_index value output, layers stack order specified. count layer analyze layer occupy block rows. ord_layer_index column (hidden kable output present data) keeps ordered correctly.","code":"geo_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   pos_vals <- vals[!is.na(vals) & vals > 0]   data.frame(     geo_mean = exp(mean(log(pos_vals)))   ) }  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\",       by = \"Gender\",       settings = layer_settings(         format_strings = list(           \"n (%)\" = f_str(\"xx (xx.x%)\", \"n\", \"pct\")         )       )     ),     group_analyze(\"AGE\",       by = \"Age (years)\",       analyze_fn = geo_fn,       settings = layer_settings(         format_strings = list(           \"Geometric Mean\" = f_str(\"xx.xx\", \"geo_mean\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"error-handling","dir":"Articles","previous_headings":"","what":"Error Handling","title":"Custom Analysis Layers","text":"analyze_fn encounters error particular group – example, group valid data log transformation – tplyr2 surface error immediately. design: silent failures statistical computation can lead subtle, hard--detect problems clinical outputs. handle edge cases gracefully, build error handling function: NA_real_ values pass format strings, tplyr2 renders blank space appropriate width, maintaining alignment output.","code":"safe_geo_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   pos_vals <- vals[!is.na(vals) & vals > 0]    if (length(pos_vals) < 2) {     return(data.frame(geo_mean = NA_real_, geo_sd = NA_real_))   }    data.frame(     geo_mean = exp(mean(log(pos_vals))),     geo_sd   = exp(sd(log(pos_vals)))   ) }  spec <- tplyr_spec(   cols = \"TRTP\",   layers = tplyr_layers(     group_analyze(\"AVAL\",       by = \"Urate (umol/L)\",       where = AVISIT == \"Baseline\",       analyze_fn = safe_geo_fn,       settings = layer_settings(         format_strings = list(           \"Geometric Mean\" = f_str(\"xxx.xx\", \"geo_mean\"),           \"Geometric SD\"   = f_str(\"xxx.xx\", \"geo_sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/analyze.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Custom Analysis Layers","text":"group_analyze() escape hatch tplyr2’s built-layer types enough. gives full control computation preserving structural benefits tplyr2 framework: column-based layout, ordering, multi-layer stacking, integration population data column headers. key points remember: analyze_fn receives .data (data.frame subset) .target_var (character string) group. format strings mode, return single-row numeric data.frame let f_str() handle formatting. pre-formatted mode, return data.frame row_label formatted columns. Use row grouping, mixing text labels data variable names needed. Build error handling function handle edge cases gracefully.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Analysis Results Data","text":"Clinical summary tables typically built human consumption: aligned columns, formatted numbers, parenthesized percentages. increasingly, regulatory industry workflows require underlying results machine-readable, standards-compliant format. Analysis Results Data (ARD) model – part broader CDISC ecosystem – addresses defining long-format structure row represents single statistic single group combination. tplyr2 supports two functions: tplyr_to_ard() converts built result ARD long format. tplyr_from_ard() reconstructs formatted table ARD data spec. Together, functions let separate computed values presentation, enabling workflows results archived, exchanged, validated independently formatting.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"converting-to-ard","dir":"Articles","previous_headings":"","what":"Converting to ARD","title":"Analysis Results Data","text":"result tplyr_build() can converted ARD format. raw numeric data already attached every build result attribute; tplyr_to_ard() melts data one-row-per-statistic long format. complete example using demographics table count descriptive statistics layers: formatted output looks like typical clinical table: Converting ARD single function call:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\"),     group_desc(       \"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))]) ard <- tplyr_to_ard(result) kable(head(ard, 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"ard-structure","dir":"Articles","previous_headings":"","what":"ARD Structure","title":"Analysis Results Data","text":"ARD output data frame long format. row represents one statistic one group combination. columns : analysis_id: integer identifying layer produced row. Layer 1 first layer spec, layer 2 second, . Grouping columns: original data variables define groups. count layer cols = \"TRT01P\" target_var = \"SEX\", see TRT01P SEX columns. stat_name: name statistic – example, \"n\", \"pct\", \"total\", \"mean\", \"sd\", \"median\", \"min\", \"max\". stat_value: numeric value statistic. Let us examine count layer (analysis_id 1) descriptive statistics layer (analysis_id 2) separately.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"count-layer-ard","dir":"Articles","previous_headings":"ARD Structure","what":"Count Layer ARD","title":"Analysis Results Data","text":"count layer produces statistics like n, pct, total combination treatment arm target variable level: sex--treatment combination three rows: raw count (n), percentage (pct), denominator (total).","code":"count_ard <- ard[ard$analysis_id == 1, ] kable(count_ard)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"descriptive-statistics-layer-ard","dir":"Articles","previous_headings":"ARD Structure","what":"Descriptive Statistics Layer ARD","title":"Analysis Results Data","text":"descriptive layer produces richer set statistics. Even format strings reference n, mean, sd, median, min, max, numeric data snapshot captures computed statistics: one key advantages ARD format: preserves every computed value, just appear formatted output.","code":"desc_ard <- ard[ard$analysis_id == 2, ] kable(head(desc_ard, 20))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"reconstructing-from-ard","dir":"Articles","previous_headings":"","what":"Reconstructing from ARD","title":"Analysis Results Data","text":"Given ARD data frame original spec, tplyr_from_ard() applies spec’s formatting rules rebuild display table. completes round-trip: reconstructed table applies format strings, row labels, column structure defined spec. means spec acts reusable formatting template: ARD data can reformatted different specs needed, spec can applied ARD data different studies.","code":"rebuilt <- tplyr_from_ard(ard, spec) kable(rebuilt[, !grepl(\"^ord\", names(rebuilt))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"verifying-the-round-trip","dir":"Articles","previous_headings":"Reconstructing from ARD","what":"Verifying the Round-Trip","title":"Analysis Results Data","text":"can confirm formatted values match original build ARD reconstruction: formatted cell values identical, confirming information lost conversion.","code":"original_sorted <- result[order(result$rowlabel1), ] rebuilt_sorted  <- rebuilt[order(rebuilt$rowlabel1), ]  all(trimws(original_sorted$res1) == trimws(rebuilt_sorted$res1)) #> [1] TRUE"},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"standards-compliant-data-exchange","dir":"Articles","previous_headings":"Use Cases","what":"Standards-Compliant Data Exchange","title":"Analysis Results Data","text":"submitting results regulatory agency sharing across organizations, ARD format provides self-describing, tool-agnostic representation computed values. long format straightforward validate, compare across submissions, load analysis environment.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"separating-computation-from-presentation","dir":"Articles","previous_headings":"Use Cases","what":"Separating Computation from Presentation","title":"Analysis Results Data","text":"production workflow, might compute results , archive ARD, apply formatting later – apply different formatting different audiences. spec defines presentation; ARD holds numbers. underlying data now appears compact layout, counts displayed without percentages two descriptive statistics rows.","code":"# Same ARD, different formatting compact_spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(       \"SEX\",       settings = layer_settings(         format_strings = list(n_counts = f_str(\"xx\", \"n\"))       )     ),     group_desc(       \"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"    = f_str(\"xx\", \"n\"),           \"Mean\" = f_str(\"xx.x\", \"mean\")         )       )     )   ) )  compact_result <- tplyr_from_ard(ard, compact_spec) kable(compact_result[, !grepl(\"^ord\", names(compact_result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"archiving-and-reproducibility","dir":"Articles","previous_headings":"Use Cases","what":"Archiving and Reproducibility","title":"Analysis Results Data","text":"ARD captures every computed statistic plain numeric value, serves durable archive analysis results. Paired saved spec (see vignette(\"serialize\")), full table can reproduced time without re-running analysis source data.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/ard.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Analysis Results Data","text":"ARD workflow tplyr2 straightforward: Build table tplyr_build() usual. Convert long format tplyr_to_ard() get one row per statistic. Reconstruct formatted table tplyr_from_ard() using compatible spec. separation computed results formatted output supports standards-compliant data exchange, flexible re-formatting, reproducible archiving analysis results.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Count Layers","text":"Counting things seems simple enough. look data, tally many observations fall category, move . clinical reporting, counting deceptively nuanced. demographics table needs simple frequencies. adverse events table needs number subjects experienced event total number events. disposition table might need plus custom column groupings sorting frequency. tplyr2 handles scenarios group_count(). vignette, walk common counting patterns encounter building clinical tables, starting basics building nested hierarchical summaries.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"a-simple-count","dir":"Articles","previous_headings":"","what":"A Simple Count","title":"Count Layers","text":"simplest use group_count() count levels single categorical variable. build basic disposition table showing reasons subjects discontinued study, broken planned treatment group. default, tplyr2 formats counts n (xx.x%), denominator total number observations within treatment column. Every level present data gets row, zero counts filled automatically treatment arm left gap.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"adding-a-total-column","dir":"Articles","previous_headings":"A Simple Count","what":"Adding a Total Column","title":"Count Layers","text":"many tables, need “Total” column pools treatment groups. can add one spec level total_group(). total_group() function works duplicating every row data treatment variable set label provide (, “Total”). means total column computed pipeline every column, keeping logic consistent.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   total_groups = list(total_group(\"TRT01P\", label = \"Total\")),   layers = tplyr_layers(     group_count(\"DCDECOD\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"res4\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"custom-column-groups","dir":"Articles","previous_headings":"A Simple Count","what":"Custom Column Groups","title":"Count Layers","text":"Sometimes need combine existing treatment arms new group. example, might want “Treated” column pools active dose groups. custom_group() function handles . Like total_group(), custom groups duplicate matching rows treatment variable set new label. Custom groups total groups can combined single spec need .","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   custom_groups = list(     custom_group(\"TRT01P\",       \"Treated\" = c(\"Xanomeline High Dose\", \"Xanomeline Low Dose\")     )   ),   layers = tplyr_layers(     group_count(\"DCDECOD\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"res4\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"custom-format-strings","dir":"Articles","previous_headings":"A Simple Count","what":"Custom Format Strings","title":"Count Layers","text":"default n (xx.x%) format works many tables, full control counts displayed f_str() function. Format strings use x characters define field widths: x reserves one character position. available count statistics : n – number observations pct – percentage observations (using column total denominator) total – denominator used percentage calculation distinct_n – number distinct subjects (requires distinct_by) distinct_pct – percentage distinct subjects distinct_total – distinct denominator can combine single format string. use distinct variants next section.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xxx (xxx.x%)\", \"n\", \"pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"total-rows","dir":"Articles","previous_headings":"A Simple Count","what":"Total Rows","title":"Count Layers","text":"Many tables require “Total” row bottom count block. Set total_row = TRUE layer_settings() add one.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         total_row = TRUE,         total_row_label = \"Overall Total\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"distinct-versus-event-counts","dir":"Articles","previous_headings":"","what":"Distinct Versus Event Counts","title":"Count Layers","text":"summarizing adverse events, distinction events subjects matters enormously. single subject might experience event multiple times. simply count rows, counting events. want number subjects experienced event least , need distinct counts. distinct_by parameter layer_settings() tells tplyr2 variable identifies unique subjects. set, distinct_n distinct_pct statistics become available use format strings. output, first number count distinct subjects, percentage based distinct subjects, number brackets total event count. pattern – xxx (xx.x%) [xxx] distinct subjects, percent, events – one common formats adverse event tables.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%) [xxx]\", \"distinct_n\", \"distinct_pct\", \"n\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")], 10))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"a-note-on-parenthesis-hugging","dir":"Articles","previous_headings":"Distinct Versus Event Counts","what":"A Note on Parenthesis Hugging","title":"Count Layers","text":"may notice tplyr2 carefully aligns numbers within format fields, padding leading spaces decimal points parentheses line across rows. even tighter alignment, tplyr2 supports “parenthesis hugging” using uppercase X characters format strings. use X instead x, leading spaces shift outside parenthesis opening delimiter sits right next number. advanced feature covered detail format strings documentation.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"nested-count-summaries","dir":"Articles","previous_headings":"","what":"Nested Count Summaries","title":"Count Layers","text":"Adverse event tables clinical reports almost always use hierarchical structure: body system (SOC) outer grouping preferred term (PT) inner grouping. tplyr2 supports directly passing vector two variable names group_count(). first variable vector (AEBODSYS) becomes outer level, second (AEDECOD) becomes inner level. output, rowlabel1 holds body system name rowlabel2 holds preferred term. Outer-level summary rows empty rowlabel2, inner-level rows preferred term indented within rowlabel2. outer-level counts represent number distinct subjects event body system, inner-level counts represent subjects specific preferred term. subject experienced multiple different preferred terms within body system counted outer level preferred term inner level.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"collapsing-row-labels","dir":"Articles","previous_headings":"Nested Count Summaries","what":"Collapsing Row Labels","title":"Count Layers","text":"display purposes, often want single row label column indentation indicating hierarchy rather two separate columns. collapse_row_labels() function merges rowlabel columns one. indent parameter controls string used level nesting. use three spaces, can use string suits output format.","code":"collapsed <- collapse_row_labels(result, \"rowlabel1\", \"rowlabel2\", indent = \"   \") kable(head(collapsed[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"controlling-indentation-at-the-layer-level","dir":"Articles","previous_headings":"Nested Count Summaries","what":"Controlling Indentation at the Layer Level","title":"Count Layers","text":"can also control indentation inner-level labels directly layer settings using indentation parameter. sets prefix applied rowlabel2 values post-processing.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         indentation = \"    \",         format_strings = list(           n_counts = f_str(\"xxx\", \"n\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 12))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"nested-counts-with-total-rows","dir":"Articles","previous_headings":"Nested Count Summaries","what":"Nested Counts with Total Rows","title":"Count Layers","text":"Total rows work nested counts well. total_row = TRUE set nested layer, total row reflects overall count across body systems.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         total_row = TRUE,         total_row_label = \"Any adverse event\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) collapsed <- collapse_row_labels(result, \"rowlabel1\", \"rowlabel2\", indent = \"   \") kable(head(collapsed[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/count.html","id":"where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Where to Go from Here","title":"Count Layers","text":"Count layers tplyr2 cover wide range clinical table patterns, much explore. related topics covered vignettes: Denominators: Control percentages calculated denoms_by denom_ignore layer_settings(). Missing counts: Add rows missing values missing_count parameter. Shift tables: Use group_shift() cross-tabulation baseline versus post-baseline categories. Descriptive statistics: Use group_desc() continuous variable summaries like mean, median, standard deviation. Post-processing: Apply row masks, conditional formatting, row label collapsing polish final output.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Denominators","text":"clinical table displays percentage, natural question : percentage ? denominator – number bottom fraction – drives interpretation every count cell output. disposition table typically uses total number subjects treatment arm. adverse event table stratified gender might need number subjects within treatment--gender combination. subgroup analysis might exclude certain categories denominator entirely. tplyr2 provides several mechanisms controlling denominators count layers, configured layer_settings(). vignette walks one, starting default behavior building specialized scenarios.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"default-behavior","dir":"Articles","previous_headings":"","what":"Default Behavior","title":"Denominators","text":"default, tplyr2 uses column variable total denominator. spec uses cols = \"TRT01P\", denominator cell total number rows treatment group. percentage computed total count within column. Placebo arm, 86 subjects, WHITE row shows 78 (90.7%) 78 / 86 = 90.7%. default appropriate simple tables, many real-world scenarios call something different.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"controlling-denominator-grouping-with-denoms_by","dir":"Articles","previous_headings":"","what":"Controlling Denominator Grouping with denoms_by","title":"Denominators","text":"denoms_by parameter layer_settings() lets specify exactly variables define denominator groups. add variable count layer, default denominator still column total. sometimes want percentage reflect subgroup population instead. Consider disposition table broken sex. default denominator, cell percentage based total treatment arm count: percentages use full treatment arm denominator. want sex subgroup sum 100% independently, set denoms_by include column variable variable: Now denominator cell count subjects specific treatment--sex combination. female Placebo subjects denominator, male Placebo subjects , . Within sex--treatment group, percentages sum 100%. denoms_by parameter accepts character vector variable names present data. restricted column variables – use grouping makes sense analysis.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       by = \"SEX\"     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 10)) spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       by = \"SEX\",       settings = layer_settings(         denoms_by = c(\"TRT01P\", \"SEX\")       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 10))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"separate-denominator-populations-with-denom_where","dir":"Articles","previous_headings":"","what":"Separate Denominator Populations with denom_where","title":"Denominators","text":"Sometimes denominator come different subset data numerator. denom_where parameter accepts quoted expression filters data used denominator computation, leaving numerator counts unaffected. example, suppose want show disposition categories compute percentages relative subjects complete study: Notice COMPLETED row now shows percentages exceeding 100%. numerator (subjects completed) larger denominator (subjects complete). expected using denom_where – shifts frame reference percentage calculation without changing rows appear count. feature particularly useful adverse event tables might want restrict denominator safety population subjects received least one dose study medication.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         denom_where = quote(DCDECOD != \"COMPLETED\")       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"excluding-values-from-denominators-with-denom_ignore","dir":"Articles","previous_headings":"","what":"Excluding Values from Denominators with denom_ignore","title":"Denominators","text":"denom_ignore parameter removes specific values target variable denominator calculation. Unlike denom_where, filters rows based arbitrary condition, denom_ignore targets specific levels variable counted. useful categorical variable includes level like “APPLICABLE” “ASSESSED” contribute total. exclude “AMERICAN INDIAN ALASKA NATIVE” denominator counting race categories: “AMERICAN INDIAN ALASKA NATIVE” row still appears output count, subjects category excluded denominator used calculate percentages. means remaining categories percentages sum slightly 100% (“AMERICAN INDIAN ALASKA NATIVE” count removed bottom fraction included numerator row). can pass multiple values denom_ignore character vector.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\",       settings = layer_settings(         denom_ignore = c(\"AMERICAN INDIAN OR ALASKA NATIVE\")       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"denominators-with-distinct-counts","dir":"Articles","previous_headings":"","what":"Denominators with Distinct Counts","title":"Denominators","text":"distinct_by set layer_settings(), tplyr2 computes event-level subject-level counts. denominator system applies separately : n pct use event-level (row-level) denominator distinct_n distinct_pct use distinct-subject denominator denominators respect denoms_by, denom_where, denom_ignore. first number count distinct subjects, percentage proportion distinct subjects, bracketed number total event count. denominators distinct_n distinct_pct total number distinct subjects per treatment arm (rather total number event rows).","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xx (xx.x%) [xxx]\", \"distinct_n\", \"distinct_pct\", \"n\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"denominators-with-population-data","dir":"Articles","previous_headings":"","what":"Denominators with Population Data","title":"Denominators","text":"many clinical studies, analysis data contains subset randomized population. Adverse event data, example, includes subjects experienced least one event. compute denominators event data alone, undercount population. pop_data() configuration spec level tells tplyr2 draw denominators separate population dataset. pop_data specified, denominator treatment arm comes population dataset rather analysis data. Without pop_data, denominators come AE dataset . , come full ADSL population. typically produces smaller percentages denominator larger – includes randomized subjects, just events. named vector pop_data(cols = c(\"TRTA\" = \"TRT01P\")) maps analysis data column name (TRTA) corresponding population data column name (TRT01P). mapping necessary column variables different names across datasets. can also retrieve population-level N values used column headers:","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(cols = c(\"TRTA\" = \"TRT01P\")),   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")], 8)) kable(tplyr_header_n(result))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"missing-subjects","dir":"Articles","previous_headings":"","what":"Missing Subjects","title":"Denominators","text":"using population data, subjects population may appear analysis data . missing_subjects parameter adds row counts absent subjects. “reported” row counts subjects present population (ADSL) records analysis data (ADAE). particularly important adverse event tables, large proportion safety population may reported events. missing_subjects_label parameter controls text displayed row label. defaults \"Missing\", \"reported\" \"events reported\" common alternatives adverse event tables. Note missing_subjects requires pop_data set spec level. Without separate population dataset, reference population identify missing subjects .","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(cols = c(\"TRTA\" = \"TRT01P\")),   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         missing_subjects = TRUE,         missing_subjects_label = \"Not reported\",         format_strings = list(           n_counts = f_str(\"xx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl)  # Show the \"Not reported\" row nr_idx <- which(result$rowlabel1 == \"Not reported\") kable(result[nr_idx, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting It All Together","title":"Denominators","text":"practice, often combine several features single layer. complete adverse event summary uses population-based denominators, distinct subject counts, missing subjects row: spec includes population-based denominators ADSL, “Total” column, nested body system / preferred term counts, row subjects reported events. denominator every cell comes full population dataset, percentages reflect proportion randomized subjects arm.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(cols = c(\"TRTA\" = \"TRT01P\")),   total_groups = list(total_group(\"TRTA\", label = \"Total\")),   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         missing_subjects = TRUE,         missing_subjects_label = \"No events reported\",         format_strings = list(           n_counts = f_str(\"xx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl) collapsed <- collapse_row_labels(result, \"rowlabel1\", \"rowlabel2\", indent = \"   \")  # Show the first section plus the missing subjects row nr_idx <- which(collapsed$row_label == \"No events reported\") show_rows <- c(1:12, nr_idx) kable(collapsed[show_rows, c(\"row_label\", \"res1\", \"res2\", \"res3\", \"res4\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/denom.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Denominators","text":"table summarizes denominator controls available layer_settings(): can used independently combined needed. key principle numerator (counting) denominator (dividing ) can controlled separately, giving precise control percentages computed clinical tables.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Descriptive Statistics Layers","text":"Descriptive statistics tables among common outputs clinical trial reporting. Whether summarizing demographics Table 14.1 lab parameters across visits, pattern : compute summary statistics continuous variable, present formatted, publication-ready layout grouped treatment arm. tplyr2, descriptive statistics layers created group_desc(). core control output comes format_strings parameter within layer_settings(). Format strings let specify exactly statistics appear, row label statistic gets, numbers formatted – one place. Let’s start typical example. Using built-tplyr_adsl dataset, summarize age treatment group. things note example: format_strings parameter named list. name becomes row label output (e.g., “Mean (SD)”), value f_str() object controls numeric format. Inside f_str(), first argument format template. characters x define display width: xx.x means two integer digits one decimal place. remaining arguments strings naming statistics plug format group. argument \"Age (years)\" match column data, tplyr2 treats text label. appears additional rowlabel column, useful distinguishing blocks statistics multiple layers combined.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       by = \"Age (years)\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\"),           \"Q1, Q3\"     = f_str(\"xx.x, xx.x\", \"q1\", \"q3\"),           \"Min, Max\"   = f_str(\"xx, xx\", \"min\", \"max\"),           \"Missing\"    = f_str(\"xx\", \"missing\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"built-in-summaries","dir":"Articles","previous_headings":"","what":"Built-in Summaries","title":"Descriptive Statistics Layers","text":"tplyr2 provides set built-summary statistics cover common needs clinical reporting. computed automatically every group_desc() layer – simply reference name format strings. important notes built-summaries: statistics use na.rm = TRUE default, missing values excluded calculations (except missing , counts ). min max operate finite values . values group NA, result NA_real_ rather Inf -Inf. avoids formatting issues infinity symbols appear output. n statistic counts non-missing observations, missing counts NA values. Together sum total number rows group.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"quantile-algorithm","dir":"Articles","previous_headings":"Built-in Summaries","what":"Quantile Algorithm","title":"Descriptive Statistics Layers","text":"default, tplyr2 uses R’s default quantile algorithm (Type 7) computing q1, q3, iqr. fine many applications, clinical trial reporting often needs match SAS output, uses different algorithm (closest R’s Type 3). can change quantile algorithm globally using tplyr2_options(): Type 7 (R default) Type 3 (SAS-like) Notice quartile values differ two algorithms. difference typically small can matter need produce outputs match SAS exactly. Type 3 uses nearest even order statistic closest match SAS’s default behavior.","code":"# Default Type 7 (R default) spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"Q1, Q3\" = f_str(\"xx.x, xx.x\", \"q1\", \"q3\")         )       )     )   ) )  result_type7 <- tplyr_build(spec, tplyr_adsl) kable(result_type7[, !grepl(\"^ord\", names(result_type7))],       caption = \"Type 7 (R default)\") # Type 3 (matches SAS PROC UNIVARIATE default) tplyr2_options(quantile_type = 3)  result_type3 <- tplyr_build(spec, tplyr_adsl) kable(result_type3[, !grepl(\"^ord\", names(result_type3))],       caption = \"Type 3 (SAS-like)\") # Reset to default tplyr2_options(quantile_type = 7)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"custom-summaries","dir":"Articles","previous_headings":"","what":"Custom Summaries","title":"Descriptive Statistics Layers","text":"built-summaries cover standard needs, clinical reporting sometimes calls statistics part default set – geometric means, coefficients variation, trimmed means, . tplyr2 handles custom summaries.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"layer-level-custom-summaries","dir":"Articles","previous_headings":"Custom Summaries","what":"Layer-Level Custom Summaries","title":"Descriptive Statistics Layers","text":"can define custom summaries directly layer_settings() using custom_summaries parameter. custom summary named expression uses .var placeholder target variable’s values. example computing geometric mean alongside standard mean: key points custom summaries: Use quote() wrap expression. delays evaluation build time, .var replaced actual data vector. .var refers values target variable current group. behaves like numeric vector, can apply R function . custom summary expression throws error (e.g., trying take log negative values), tplyr2 catches error returns NA_real_ group, table build fail.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"              = f_str(\"xx\", \"n\"),           \"Mean (SD)\"      = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Geometric Mean\" = f_str(\"xx.xx\", \"geo_mean\")         ),         custom_summaries = list(           geo_mean = quote(exp(mean(log(.var[.var > 0]), na.rm = TRUE)))         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"session-level-custom-summaries","dir":"Articles","previous_headings":"Custom Summaries","what":"Session-Level Custom Summaries","title":"Descriptive Statistics Layers","text":"find using custom summary across many tables study, can register session level using tplyr2_options(). registered, custom statistic available name format_strings specification, just like built-summaries.","code":"# Register a coefficient of variation summary for the session tplyr2_options(   custom_summaries = list(     cv = quote(sd(.var, na.rm = TRUE) / mean(.var, na.rm = TRUE) * 100)   ) )  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"CV (%)\"     = f_str(\"xx.x\", \"cv\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))]) # Clean up tplyr2_options(custom_summaries = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"overriding-built-in-summaries","dir":"Articles","previous_headings":"Custom Summaries","what":"Overriding Built-in Summaries","title":"Descriptive Statistics Layers","text":"Custom summaries can even overwrite built-statistics. name custom summary \"mean\", replaces built-mean calculation. useful study requires non-standard definition standard statistic, using trimmed mean instead arithmetic mean. Layer-level custom summaries always take priority session-level custom summaries, take priority built-statistics. layered precedence gives fine-grained control: set sensible defaults session level, override per-layer basis needed.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"Trimmed Mean\" = f_str(\"xx.x\", \"mean\")         ),         custom_summaries = list(           mean = quote(mean(.var, trim = 0.1, na.rm = TRUE))         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"multi-variable-descriptive-statistics","dir":"Articles","previous_headings":"","what":"Multi-Variable Descriptive Statistics","title":"Descriptive Statistics Layers","text":"common summarize several continuous variables single table – example, demographics table includes age, height, weight. Rather creating separate layers variable, can pass character vector variable names group_desc(). multiple target variables specified: variable gets block summary rows. variable name appears additional rowlabel column (, rowlabel1), statistic labels next column (rowlabel2). format_strings applied every variable. variable’s statistics computed independently, differences scale (e.g., age years vs. height centimeters) handled naturally. Ordering preserved: first variable’s rows appear first, followed second, . can also combine multi-variable descriptive layers parameter. add text label , becomes outermost row label, followed variable name, statistic label.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(c(\"AGE\", \"HEIGHTBL\", \"WEIGHTBL\"),       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\"),           \"Q1, Q3\"     = f_str(\"xx.x, xx.x\", \"q1\", \"q3\"),           \"Min, Max\"   = f_str(\"xx, xx\", \"min\", \"max\"),           \"Missing\"    = f_str(\"xx\", \"missing\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))]) spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(c(\"AGE\", \"WEIGHTBL\"),       by = \"Demographics\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc.html","id":"where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Where to Go From Here","title":"Descriptive Statistics Layers","text":"vignette covered fundamentals descriptive statistics layers tplyr2: built-summaries, custom summaries, quantile algorithms, multi-variable analysis. explore comes controlling numbers look page. vignette(\"desc_layer_formatting\") vignette dives advanced formatting topics including: Auto-precision: Dynamically adjusting decimal places based precision collected data, using precision_by, precision_on, precision_cap layer_settings(). Empty value handling: Controlling appears values group missing, using empty parameter f_str(). Parenthesis hugging: Eliminating gap parentheses numbers formats like ( 5.2) become (5.2 ) using X character format strings.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"empty-value-formatting","dir":"Articles","previous_headings":"","what":"Empty Value Formatting","title":"Advanced Descriptive Statistics Formatting","text":"observations group NA, tplyr2 fills cell whitespace default. empty parameter f_str() overrides . Use .overall replace entire formatted string: Group C -NA values, Mean (SD) shows “—” Median shows “NE”. f_str() can specify replacement string independently.","code":"test_data <- data.frame(   TRT = c(rep(\"A\", 5), rep(\"B\", 5), rep(\"C\", 3)),   VAL = c(1.5, 2.3, 3.1, 4.0, 2.7,           5.2, 6.1, 3.8, 4.4, 7.0,           NA, NA, NA),   stringsAsFactors = FALSE )  spec <- tplyr_spec(   cols = \"TRT\",   layers = tplyr_layers(     group_desc(\"VAL\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\",                               empty = c(.overall = \"---\")),           \"Median\"    = f_str(\"xx.x\", \"median\",                               empty = c(.overall = \"NE\"))         )       )     )   ) )  result <- tplyr_build(spec, test_data) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"auto-precision","dir":"Articles","previous_headings":"","what":"Auto-Precision","title":"Advanced Descriptive Statistics Formatting","text":"Fixed format strings like \"xx.x\" work know data’s scale. lab parameters vary widely precision. auto-precision system lets data determine many digits display.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"core-settings","dir":"Articles","previous_headings":"Auto-Precision","what":"Core Settings","title":"Advanced Descriptive Statistics Formatting","text":"Two layer_settings() parameters drive auto-precision: precision_on: variable scanned decimal precision (defaults target variable) precision_by: grouping variables define independent precision groups group, tplyr2 computes max_int (maximum integer digits) max_dec (maximum meaningful decimal places) data.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"the-a-character","dir":"Articles","previous_headings":"Auto-Precision","what":"The a Character","title":"Advanced Descriptive Statistics Formatting","text":"format strings, lowercase means “use data-driven width”: .resolves max_int integer digits max_dec decimal places .+1 adds one extra decimal place beyond data’s precision +2.adds two extra integer digits +N suffix standard clinical practice – typically mean gets +1 SD gets +2 beyond raw data’s precision. Since AVAL tplyr_adlb three decimal places, .resolves three decimals. mean (.+1) displays four, SD (.+2) displays five.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"PARAMCD\",       settings = layer_settings(         precision_by = \"PARAMCD\",         precision_on = \"AVAL\",         format_strings = list(           \"n\"         = f_str(\"xx\", \"n\"),           \"Mean (SD)\" = f_str(\"a.a+1 (a.a+2)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"a.a+1\", \"median\"),           \"Min, Max\"  = f_str(\"a.a, a.a\", \"min\", \"max\"),           \"Missing\"   = f_str(\"xx\", \"missing\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"precision-capping","dir":"Articles","previous_headings":"","what":"Precision Capping","title":"Advanced Descriptive Statistics Formatting","text":"Auto-precision can produce unreasonably wide columns data extreme precision. Capping sets upper bounds resolved widths.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"layer-level-cap","dir":"Articles","previous_headings":"Precision Capping","what":"Layer-Level Cap","title":"Advanced Descriptive Statistics Formatting","text":"Set precision_cap layer_settings() named vector int /dec components: dec = 2, base precision capped two decimals. mean shows three (+1), SD shows four (+2), Min/Max uses capped base two.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"PARAMCD\",       settings = layer_settings(         precision_by = \"PARAMCD\",         precision_on = \"AVAL\",         precision_cap = c(int = 3, dec = 2),         format_strings = list(           \"Mean (SD)\" = f_str(\"a.a+1 (a.a+2)\", \"mean\", \"sd\"),           \"Min, Max\"  = f_str(\"a.a, a.a\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"global-cap","dir":"Articles","previous_headings":"Precision Capping","what":"Global Cap","title":"Advanced Descriptive Statistics Formatting","text":"Use tplyr2_options() set session-wide cap: layer-level cap always overrides global option, can set conservative session defaults widen specific layers needed.","code":"tplyr2_options(precision_cap = c(int = 3, dec = 1))  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))]) tplyr2_options(precision_cap = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"external-precision-data","dir":"Articles","previous_headings":"","what":"External Precision Data","title":"Advanced Descriptive Statistics Formatting","text":"precision predetermined statistical analysis plan, supply directly via precision_data – data.frame max_int max_dec columns, plus precision_by grouping columns: max_dec = 1, mean shows two decimals (+1) Min/Max shows one, regardless data’s actual three-decimal precision.","code":"ext_precision <- data.frame(   PARAMCD = \"URATE\",   max_int = 3L,   max_dec = 1L,   stringsAsFactors = FALSE )  spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"PARAMCD\",       settings = layer_settings(         precision_by = \"PARAMCD\",         precision_on = \"AVAL\",         precision_data = ext_precision,         format_strings = list(           \"Mean (SD)\" = f_str(\"a.a+1 (a.a+2)\", \"mean\", \"sd\"),           \"Min, Max\"  = f_str(\"a.a, a.a\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"parenthesis-hugging","dir":"Articles","previous_headings":"","what":"Parenthesis Hugging","title":"Advanced Descriptive Statistics Formatting","text":"Standard formatting pads numbers leading spaces alignment, can create gaps like ( 5.2). Parenthesis hugging shifts leading spaces number, producing (5.2 ) instead.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"the-x-and-a-characters","dir":"Articles","previous_headings":"Parenthesis Hugging","what":"The X and A Characters","title":"Advanced Descriptive Statistics Formatting","text":"Uppercase characters activate hugging: X – fixed width hugging (uppercase x) – auto-precision hugging (uppercase ) “Standard”, SD leading spaces number inside parentheses. “Hugged”, spaces shift number parenthesis sits flush first digit.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"Standard\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Hugged\"    = f_str(\"xx.x (XX.xx)\", \"mean\", \"sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"hugging-with-auto-precision","dir":"Articles","previous_headings":"Parenthesis Hugging","what":"Hugging with Auto-Precision","title":"Advanced Descriptive Statistics Formatting","text":"Uppercase combines auto-precision hugging: mean uses lowercase (standard padding) SD uses uppercase (hugged). combination auto-precision data-driven width plus hugging tight delimiters standard approach publication-quality lab tables.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"PARAMCD\",       settings = layer_settings(         precision_by = \"PARAMCD\",         precision_on = \"AVAL\",         format_strings = list(           \"Mean (SD)\" = f_str(\"a.a+1 (A.A+2)\", \"mean\", \"sd\"),           \"Min [Max]\" = f_str(\"a.a [A.a]\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/desc_layer_formatting.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting It All Together","title":"Advanced Descriptive Statistics Formatting","text":"complete specification combining formatting features covered : specification adapts decimal places data, caps precision three decimals, hugs SD opening parenthesis, provides meaningful fill strings -NA groups.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"PARAMCD\",       settings = layer_settings(         precision_by = \"PARAMCD\",         precision_on = \"AVAL\",         precision_cap = c(int = 4, dec = 3),         format_strings = list(           \"n\"         = f_str(\"xx\", \"n\"),           \"Mean (SD)\" = f_str(\"a.a+1 (A.A+2)\", \"mean\", \"sd\",                               empty = c(.overall = \"\")),           \"Median\"    = f_str(\"a.a+1\", \"median\",                               empty = c(.overall = \"NE\")),           \"Q1, Q3\"    = f_str(\"a.a+1, a.a+1\", \"q1\", \"q3\"),           \"Min, Max\"  = f_str(\"a.a, a.a\", \"min\", \"max\"),           \"Missing\"   = f_str(\"xx\", \"missing\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"General String Formatting","text":"Clinical tables live die alignment. reviewer scans column numbers, decimal points must line , parentheses must sit position row row, whitespace must consistent. One misaligned digit table looks unprofessional – worse, raises questions numbers . tplyr2 solves format strings: compact notation describes exactly wide number field , decimals fall, padding works. f_str() function entry point. give template string names statistics fill slot, tplyr2 takes care rest.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"how-format-strings-work","dir":"Articles","previous_headings":"","what":"How Format Strings Work","title":"General String Formatting","text":"format string character template containing one format groups separated literal text. format group corresponds one statistic. example: xx.x first format group (mean): two integer digits, one decimal digit. ( literal separator first second groups. xx.xx second format group (sd): two integer digits, two decimal digits. ) trailing literal. number x characters determines field width. x reserves exactly one character position output, numbers narrower field left-padded spaces maintain alignment across rows.","code":"# Two format groups separated by the literal \" (\"  and closing \")\" fmt <- f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\") fmt #> tplyr format string: \"xx.x (xx.xx)\"Variables: mean, sd"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"available-variables-by-layer-type","dir":"Articles","previous_headings":"","what":"Available Variables by Layer Type","title":"General String Formatting","text":"layer type computes specific set statistics can reference format strings. count layers, format strings provided named list key n_counts. descriptive statistics layers, named entry format_strings list becomes separate output row, name used row label.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"lowercase-x-fixed-width-fields","dir":"Articles","previous_headings":"","what":"Lowercase x: Fixed-Width Fields","title":"General String Formatting","text":"x character workhorse format strings. x reserves one character position. number fewer digits number x characters, output left-padded spaces. number digits available positions, number prints full (never truncated). Notice numbers align within column. xx.x format mean creates field three characters wide decimal one , mean 75.2 prints 75.2 mean 8.3 print 8.3 (leading space). consistent field width makes clinical tables scannable.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       by = \"Age (years)\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\"),           \"Q1, Q3\"     = f_str(\"xx.x, xx.x\", \"q1\", \"q3\"),           \"Min, Max\"   = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"uppercase-x-parenthesis-hugging","dir":"Articles","previous_headings":"","what":"Uppercase X: Parenthesis Hugging","title":"General String Formatting","text":"Standard x formatting pads numbers inside surrounding delimiters. means parenthesis bracket can end separated number encloses one spaces, can look awkward: Uppercase X solves parenthesis hugging. format group uses X characters, leading spaces normally appear inside number field shifted outside preceding delimiter. result opening parenthesis (bracket) always sits immediately next first significant digit. standard formatting, padding sits parenthesis number: data parenthesis hugging applied percentage group. opening parenthesis now hugs number, displaced spaces move left parenthesis: total string width stays – spaces disappear, just relocate. preserves column alignment giving output cleaner look. Parenthesis hugging works delimiter appears literal format string, including square brackets [ characters.","code":"14 ( 16.3%)   7 (  8.1%) # Standard formatting: spaces inside parentheses spec_standard <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xxx (xxx.x%)\", \"n\", \"pct\")         )       )     )   ) )  result_standard <- tplyr_build(spec_standard, tplyr_adsl)  # Parenthesis hugging: spaces shift outside the delimiter spec_hugged <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xxx (XXX.x%)\", \"n\", \"pct\")         )       )     )   ) )  result_hugged <- tplyr_build(spec_hugged, tplyr_adsl) kable(result_standard[1:6, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")]) kable(result_hugged[1:6, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"auto-precision-with-a-and-a","dir":"Articles","previous_headings":"","what":"Auto-Precision with a and A","title":"General String Formatting","text":"descriptive statistics tables, appropriate number decimal places often depends data . lab parameter measured one decimal place summarized one two decimal digits, one measured three decimal places needs . Hardcoding widths every parameter tedious error-prone. characters enable auto-precision: field width determined build time actual data. Specifically, tplyr2 scans target variable, finds maximum number decimal places present, uses base precision. – auto-precision digit (like x, width comes data) – auto-precision parenthesis hugging (like X, width comes data) +N suffix – adds N auto-determined width (e.g., +1 means data precision plus one extra decimal place) Auto-precision controlled three settings layer_settings(): precision_by: character vector grouping variables (precision computed per group) precision_on: character name variable scan precision (defaults target variable) precision_cap: named numeric vector c(int = , dec = ) cap maximum widths example, precision_on = \"AVAL\" tells tplyr2 scan AVAL column determine number decimal places present data. +1 +2 suffixes add one two extra decimal places beyond data contains. Min, Max, .uses raw data precision extra digits. precision_by also set, precision computed separately group – useful single spec covers multiple lab parameters, measured different scale. means can write one spec handles dozens parameters, rendered precision appropriate measurement. Note auto-precision characters can also used count layers. instance, integer portion count format auto-size field width based data, guess many digits largest count require.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_desc(\"AVAL\",       by = \"Urate (umol/L)\",       where = AVISIT %in% c(\"Baseline\", \"Week 12\", \"Week 24\"),       settings = layer_settings(         precision_on = \"AVAL\",         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"a+1.a+1 (a+2.a+2)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"a+1.a+1\", \"median\"),           \"Q1, Q3\"     = f_str(\"a+1.a+1, a+1.a+1\", \"q1\", \"q3\"),           \"Min, Max\"   = f_str(\"a.a, a.a\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adlb) kable(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"the-empty-argument","dir":"Articles","previous_headings":"","what":"The empty Argument","title":"General String Formatting","text":"statistic NA (example, standard deviation n = 1), format strings produce blank space default preserve alignment. can override empty argument f_str(), specifies replacement string values format group missing. .overall key means replacement applies statistics string NA. useful displaying dash placeholder rows summary computed.","code":"fmt_with_empty <- f_str(   \"xx.x (xx.xx)\",   \"mean\", \"sd\",   empty = c(.overall = \"   -\") ) fmt_with_empty #> tplyr format string: \"xx.x (xx.xx)\"Variables: mean, sdEmpty: c(.overall = \"   -\")"},{"path":"https://github.com/mstackhouse/tplyr2/articles/general_string_formatting.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting It All Together","title":"General String Formatting","text":"Let us build complete example: adverse event summary combines parenthesis hugging fixed-width fields, similar see clinical study report. table: xxx gives three-digit fixed field distinct subject counts. XXX.x uses parenthesis hugging ( sits right next percentage value. % sign literal text appears percentage every cell. distinct_n distinct_pct compute subject-level (event-level) summaries. Nested counts display body system totals alongside preferred term detail. format string system tplyr2 designed declare shape number field , package handles padding, alignment, precision across every cell table. Whether need fixed widths, data-driven precision, delimiter-hugging alignment, f_str() interface covers three.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (XXX.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) collapsed <- collapse_row_labels(result, \"rowlabel1\", \"rowlabel2\", indent = \"   \") kable(head(collapsed[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"why-traceability-matters","dir":"Articles","previous_headings":"","what":"Why Traceability Matters","title":"Metadata and Traceability","text":"Clinical summary tables go rigorous quality control. reviewer questions number, programmer needs trace cell back exact rows source data produced . Without systematic approach, means re-reading code, reconstructing filter logic, manually subsetting data – tedious error-prone process. tplyr2 solves cell-level metadata. build table metadata = TRUE, package records filter expressions define every cell. can query cell inspect filters retrieve source data rows directly. valuable regulatory review, quality control, powering interactive drill-interfaces Shiny applications.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"building-with-metadata","dir":"Articles","previous_headings":"","what":"Building with Metadata","title":"Metadata and Traceability","text":"Enabling metadata single argument tplyr_build(): returned data frame two additions compared normal build: row_id column containing unique identifier output row. tplyr_meta attribute – named list metadata objects keyed \"row_id||column\".","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\"),     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\" = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"row-ids","dir":"Articles","previous_headings":"","what":"Row IDs","title":"Metadata and Traceability","text":"Row IDs constructed layer index row label values. count layer target_var = \"SEX\" layer 1, IDs 1_F 1_M. descriptive statistics layer layer 2, 2_n 2_Mean (SD). IDs deterministic – building spec data always produces values. generate_row_ids() function creates identifiers can also called tplyr2 output, even one built without metadata.","code":"result$row_id #> [1] \"1_F\"         \"1_M\"         \"2_n\"         \"2_Mean (SD)\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"inspecting-cell-metadata","dir":"Articles","previous_headings":"","what":"Inspecting Cell Metadata","title":"Metadata and Traceability","text":"row ID column name, tplyr_meta_result() returns metadata object cell: tplyr_meta object contains: names: Variable names relevant cell. filters: list R call expressions , combined &, define data subset. layer_index: layer cell belongs . anti_join: NULL normal cells, tplyr_meta_anti_join object missing subjects rows. cell exist, function returns NULL. try access metadata result built without , get clear error:","code":"meta <- tplyr_meta_result(result, \"1_F\", \"res1\") meta #> tplyr_meta [layer 1] #>   Names: TRT01P, SEX #>   Filters: #>     TRT01P == \"Placebo\" #>     SEX == \"F\" result_no_meta <- tplyr_build(spec, tplyr_adsl, metadata = FALSE) tplyr_meta_result(result_no_meta, \"1_F\", \"res1\") #> Error: #> ! No metadata available. Rebuild with metadata = TRUE"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"getting-source-data","dir":"Articles","previous_headings":"","what":"Getting Source Data","title":"Metadata and Traceability","text":"real power metadata tplyr_meta_subset(). evaluates stored filters original data, returning rows produced cell: number rows returned matches count displayed cell.","code":"source_rows <- tplyr_meta_subset(result, \"1_F\", \"res1\", tplyr_adsl) nrow(source_rows) #> [1] 53 all(source_rows$SEX == \"F\") #> [1] TRUE unique(source_rows$TRT01P) #> [1] \"Placebo\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"metadata-for-count-layers","dir":"Articles","previous_headings":"","what":"Metadata for Count Layers","title":"Metadata and Traceability","text":"Count cells defined intersection column variable level target variable level. variable present, adds additional filter:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\", by = \"EOSSTT\")   ) )  result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")])) rid <- result$row_id[1] meta <- tplyr_meta_result(result, rid, \"res1\") meta #> tplyr_meta [layer 1] #>   Names: TRT01P, EOSSTT, DCDECOD #>   Filters: #>     TRT01P == \"Placebo\" #>     EOSSTT == \"COMPLETED\" #>     DCDECOD == \"ADVERSE EVENT\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"total-rows","dir":"Articles","previous_headings":"Metadata for Count Layers","what":"Total Rows","title":"Metadata and Traceability","text":"total_row = TRUE, total row’s metadata omits target variable filter, leaving column variable -variables:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\", settings = layer_settings(total_row = TRUE))   ) )  result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE) total_row <- result[result$rowlabel1 == \"Total\", ] meta <- tplyr_meta_result(result, total_row$row_id, \"res1\") meta #> tplyr_meta [layer 1] #>   Names: TRT01P, SEX #>   Filters: #>     TRT01P == \"Placebo\" source_rows <- tplyr_meta_subset(result, total_row$row_id, \"res1\", tplyr_adsl) nrow(source_rows) #> [1] 86"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"metadata-for-descriptive-statistics-layers","dir":"Articles","previous_headings":"","what":"Metadata for Descriptive Statistics Layers","title":"Metadata and Traceability","text":"row desc layer represents statistic (n, mean, etc.), data category. stat rows within column point source data – observations statistics computed: names field includes target variable (AGE). can verify statistics subsetting computing directly:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\" = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE) n_meta <- tplyr_meta_result(result, \"1_n\", \"res1\") n_meta #> tplyr_meta [layer 1] #>   Names: TRT01P, AGE #>   Filters: #>     TRT01P == \"Placebo\" source_rows <- tplyr_meta_subset(result, \"1_n\", \"res1\", tplyr_adsl) c(n = nrow(source_rows), mean = mean(source_rows$AGE), sd = sd(source_rows$AGE)) #>         n      mean        sd  #> 86.000000 75.209302  8.590167"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"where-filters-in-metadata","dir":"Articles","previous_headings":"","what":"Where Filters in Metadata","title":"Metadata and Traceability","text":"spec-level layer-level filters captured metadata, can always see full filtering chain: filter list includes SAFFL == \"Y\" alongside column target variable filters. names field lists every variable subsetting logic.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   layers = tplyr_layers(     group_count(\"SEX\")   ) )  result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE) meta <- tplyr_meta_result(result, result$row_id[1], \"res1\") meta #> tplyr_meta [layer 1] #>   Names: TRT01P, SEX, SAFFL #>   Filters: #>     TRT01P == \"Placebo\" #>     SEX == \"F\" #>     SAFFL == \"Y\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"anti-join-metadata-for-missing-subjects","dir":"Articles","previous_headings":"","what":"Anti-Join Metadata for Missing Subjects","title":"Metadata and Traceability","text":"tables include row subjects population data analysis data. metadata rows uses special anti_join field: anti_join contains join_meta (filters population side) (join key, typically \"USUBJID\"). calling tplyr_meta_subset() row, must supply pop_data: Subject S4 population TRT = \"\" absent target, anti-join returns one row. Omitting pop_data produces warning:","code":"target <- data.frame(   TRT = c(\"A\", \"A\", \"B\"),   USUBJID = c(\"S1\", \"S2\", \"S3\"),   VAL = c(\"X\", \"Y\", \"X\") )  pop <- data.frame(   TRT = c(\"A\", \"A\", \"A\", \"B\", \"B\"),   USUBJID = c(\"S1\", \"S2\", \"S4\", \"S3\", \"S5\") )  spec <- tplyr_spec(   cols = \"TRT\",   pop_data = pop_data(cols = \"TRT\"),   layers = tplyr_layers(     group_count(\"VAL\",       settings = layer_settings(         distinct_by = \"USUBJID\",         missing_subjects = TRUE,         missing_subjects_label = \"Not in Target\"       )     )   ) )  result <- tplyr_build(spec, target, pop_data = pop, metadata = TRUE) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\")]) ms_row <- result[result$rowlabel1 == \"Not in Target\", ] meta <- tplyr_meta_result(result, ms_row$row_id, \"res1\") meta #> tplyr_meta [layer 1] #>   Names: TRT, VAL #>   Filters: #>     TRT == \"A\" #>   Anti-join: #>     On: USUBJID #>     Pop filters: #>       TRT == \"A\" missing_a <- tplyr_meta_subset(result, ms_row$row_id, \"res1\",                                 target, pop_data = pop) missing_a #>   TRT USUBJID #> 1   A      S4 tplyr_meta_subset(result, ms_row$row_id, \"res1\", target) #> Warning: pop_data is required for anti-join metadata but was not provided #>   TRT USUBJID VAL #> 1   A      S1   X #> 2   A      S2   Y"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"practical-applications","dir":"Articles","previous_headings":"","what":"Practical Applications","title":"Metadata and Traceability","text":"common use metadata cell verification QC: metadata system also lends Shiny applications clicking cell triggers tplyr_meta_subset(), displaying source records detail panel:","code":"result <- tplyr_build(spec, data, metadata = TRUE) source <- tplyr_meta_subset(result, row_id = \"1_F\", column = \"res2\", data = data) nrow(source) observeEvent(input$table_cell_click, {   click <- input$table_cell_click   row_id <- result$row_id[click$row]   col_name <- names(result)[click$col]   source_data <- tplyr_meta_subset(result, row_id, col_name, original_data)   output$detail_table <- renderTable(source_data) })"},{"path":"https://github.com/mstackhouse/tplyr2/articles/metadata.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Metadata and Traceability","text":"Every cell carries filter expressions – column variable, target variable, -variable, clauses, anti-join logic missing subjects. expressions stored build time evaluated request subset, keeping metadata lightweight providing exact reproducibility every number table.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Migrating from Tplyr v1","text":"Tplyr v1 tplyr2 build formatted clinical summary tables ADaM-style data, take fundamentally different approaches. Tplyr v1 uses imperative, piped workflow: create table object holding data configuration, pipe layers, set options modifier functions, call build(). tplyr2 uses declarative, spec-based approach: build tplyr_spec() pure configuration (data, side effects), supply data build time via tplyr_build(spec, data). separation makes specs portable, serializable, reusable across datasets studies. vignette covers key differences side--side examples.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"quick-reference-function-mapping","dir":"Articles","previous_headings":"","what":"Quick Reference: Function Mapping","title":"Migrating from Tplyr v1","text":"table maps v1 functions tplyr2 equivalents.","code":""},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"data-is-separated-from-configuration","dir":"Articles","previous_headings":"Key Differences in Detail","what":"Data Is Separated from Configuration","title":"Migrating from Tplyr v1","text":"v1, data lives inside table object moment create : tplyr2, spec knows nothing data. supply data ready build: means spec can applied different datasets without modifying spec .","code":"# Tplyr v1: data bound at table creation t <- tplyr_table(adsl, TRT01P) spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\")   ) )  # Data provided at build time result <- tplyr_build(spec, tplyr_adsl)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"variable-names-are-quoted-strings","dir":"Articles","previous_headings":"Key Differences in Detail","what":"Variable Names Are Quoted Strings","title":"Migrating from Tplyr v1","text":"v1, variable names bare symbols. tplyr2, character strings. required JSON/YAML serialization simpler programmatic construction. one exception , accepts bare expressions:","code":"# Tplyr v1: bare symbols              # tplyr2: quoted strings group_count(SEX)                       group_count(\"SEX\") group_desc(AGE)                        group_desc(\"AGE\") group_count(\"SEX\", where = SAFFL == \"Y\")"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"settings-are-collected-in-an-object","dir":"Articles","previous_headings":"Key Differences in Detail","what":"Settings Are Collected in an Object","title":"Migrating from Tplyr v1","text":"v1, configure layers piping modifier functions: tplyr2, configuration lives single layer_settings() object:","code":"# Tplyr v1: piped modifiers group_count(RACE) %>%   set_format_strings(f_str(\"xx (xx.x%)\", n, pct)) %>%   set_distinct_by(USUBJID) %>%   set_denoms_by(TRT01P) # tplyr2: declarative settings group_count(\"RACE\",   settings = layer_settings(     format_strings = list(n_counts = f_str(\"xx (xx.x%)\", \"n\", \"pct\")),     distinct_by = \"USUBJID\",     denoms_by = \"TRT01P\"   ) )"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"format-strings-use-quoted-variable-names","dir":"Articles","previous_headings":"Key Differences in Detail","what":"Format Strings Use Quoted Variable Names","title":"Migrating from Tplyr v1","text":"f_str() function works way, variable names now strings. desc layers, format strings named list (name becomes row label). count layers, list key n_counts:","code":"# v1: bare symbols                     # tplyr2: quoted strings f_str(\"xx (xx.x%)\", n, pct)            f_str(\"xx (xx.x%)\", \"n\", \"pct\") # Desc layer: named list of format strings format_strings = list(   \"n\"         = f_str(\"xxx\", \"n\"),   \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\") ) # Count layer: key is n_counts format_strings = list(n_counts = f_str(\"xx (xx.x%)\", \"n\", \"pct\"))"},{"path":[]},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"tplyr-v1","dir":"Articles","previous_headings":"Side-by-Side Examples > Demographics Table","what":"Tplyr v1","title":"Migrating from Tplyr v1","text":"","code":"# Tplyr v1 approach (not evaluated) tplyr_table(adsl, TRT01P, where = SAFFL == \"Y\") %>%   add_layer(     group_count(SEX, by = \"Sex n (%)\")   ) %>%   add_layer(     group_desc(AGE, by = \"Age (Years)\") %>%       set_format_strings(         \"n\"         = f_str(\"xxx\", n),         \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", mean, sd),         \"Median\"    = f_str(\"xx.x\", median),         \"Min, Max\"  = f_str(\"xx, xx\", min, max)       )   ) %>%   build()"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"tplyr2","dir":"Articles","previous_headings":"Side-by-Side Examples > Demographics Table","what":"tplyr2","title":"Migrating from Tplyr v1","text":"","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   layers = tplyr_layers(     group_count(\"SEX\", by = \"Sex n (%)\"),     group_desc(\"AGE\",       by = \"Age (Years)\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"tplyr-v1-1","dir":"Articles","previous_headings":"Side-by-Side Examples > Adverse Events Table (Nested Counts)","what":"Tplyr v1","title":"Migrating from Tplyr v1","text":"","code":"# Tplyr v1 approach (not evaluated) tplyr_table(adae, TRTA) %>%   add_layer(     group_count(vars(AEBODSYS, AEDECOD)) %>%       set_distinct_by(USUBJID) %>%       set_format_strings(f_str(\"xxx (xx.x%)\", distinct_n, distinct_pct)) %>%       set_order_count_method(\"bycount\") %>%       set_ordering_cols(\"Xanomeline High Dose\")   ) %>%   build()"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"tplyr2-1","dir":"Articles","previous_headings":"Side-by-Side Examples > Adverse Events Table (Nested Counts)","what":"tplyr2","title":"Migrating from Tplyr v1","text":"Note vars(AEBODSYS, AEDECOD) becomes c(\"AEBODSYS\", \"AEDECOD\"), piped modifiers become arguments layer_settings(), data supplied build.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         order_count_method = \"bycount\",         ordering_cols = \"Xanomeline High Dose\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, !grepl(\"^ord\", names(result))], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"new-features-in-tplyr2","dir":"Articles","previous_headings":"","what":"New Features in tplyr2","title":"Migrating from Tplyr v1","text":"Beyond API redesign, tplyr2 introduces several entirely new capabilities.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"spec-serialization","dir":"Articles","previous_headings":"New Features in tplyr2","what":"Spec Serialization","title":"Migrating from Tplyr v1","text":"Specs can saved disk JSON YAML loaded later, enabling centralized spec authoring distributed execution:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\"),     group_desc(\"AGE\")   ) )  tmp <- tempfile(fileext = \".json\") tplyr_write_spec(spec, tmp) spec_loaded <- tplyr_read_spec(tmp) spec_loaded #> tplyr2 table specification #> Column variables: TRT01PLayers: 2[1] count: SEX (Layer 1)[2] desc: AGE (Layer 2)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"custom-analysis-layers","dir":"Articles","previous_headings":"New Features in tplyr2","what":"Custom Analysis Layers","title":"Migrating from Tplyr v1","text":"group_analyze() accepts user-defined function arbitrary computations. function receives group’s data subset returns data.frame numeric results:","code":"custom_fn <- function(.data, .target_var) {   vals <- .data[[.target_var]]   data.frame(     geo_mean = exp(mean(log(vals[vals > 0]), na.rm = TRUE)),     geo_sd   = exp(sd(log(vals[vals > 0]), na.rm = TRUE))   ) }  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_analyze(\"AGE\", analyze_fn = custom_fn, settings = layer_settings(       format_strings = list(         \"Geometric Mean (SD)\" = f_str(\"xx.xx (xx.xx)\", \"geo_mean\", \"geo_sd\")       )     ))   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"cell-level-metadata","dir":"Articles","previous_headings":"New Features in tplyr2","what":"Cell-Level Metadata","title":"Migrating from Tplyr v1","text":"metadata = TRUE passed tplyr_build(), every cell carries metadata tracing back source data rows auditability:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(group_count(\"SEX\")) ) result <- tplyr_build(spec, tplyr_adsl, metadata = TRUE) row_ids <- generate_row_ids(result)  # Inspect the metadata for one cell, then retrieve its source rows tplyr_meta_result(result, row_ids[1], \"res1\") #> tplyr_meta [layer 1] #>   Names: TRT01P, SEX #>   Filters: #>     TRT01P == \"Placebo\" #>     SEX == \"F\" source_rows <- tplyr_meta_subset(result, row_ids[1], \"res1\", tplyr_adsl) kable(head(source_rows[, c(\"USUBJID\", \"SEX\", \"TRT01P\")]))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"ard-conversion-and-numeric-data","dir":"Articles","previous_headings":"New Features in tplyr2","what":"ARD Conversion and Numeric Data","title":"Migrating from Tplyr v1","text":"tplyr_to_ard() converts results long-format Analysis Results Data. tplyr_numeric_data() provides raw unformatted numbers validation:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(group_count(\"SEX\")) ) result <- tplyr_build(spec, tplyr_adsl)  kable(head(tplyr_to_ard(result), 10)) kable(tplyr_numeric_data(result, layer = 1))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/migration.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Migrating from Tplyr v1","text":"migration Tplyr v1 tplyr2 involves three main shifts: Declare, don’t pipe. Replace tplyr_table() %>% add_layer() %>% build() tplyr_spec() + tplyr_build(spec, data). Quote variable names. Bare symbols like AGE become \"AGE\". parameter place bare expressions still used. Collect settings one place. Instead piping set_*() calls, pass layer_settings() object settings parameter layer. output structure – rowlabel columns, res columns label attributes, ord columns sorting – remains . Existing downstream code consumes tplyr output work minimal changes.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"tplyr2 Options","text":"tplyr2 provides set session-level options control tables built. options let configure behaviors apply across tables session – rounding rules, quantile algorithms, precision limits, custom summary functions, scientific notation handling – without repeating every spec. tplyr2 options managed single function: tplyr2_options(). called arguments, returns current values options. called named arguments, sets options. hood, option stored standard R option tplyr2. prefix, can also set options() directly prefer.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"viewing-current-options","dir":"Articles","previous_headings":"","what":"Viewing Current Options","title":"tplyr2 Options","text":"see every option currently set , call tplyr2_options() arguments: output named list. Options changed show defaults: IBMRounding FALSE, quantile_type 7, precision_cap custom_summaries NULL, scipen 9999.","code":"tplyr2_options() #> $tplyr2.IBMRounding #> [1] FALSE #>  #> $tplyr2.quantile_type #> [1] 7 #>  #> $tplyr2.precision_cap #> NULL #>  #> $tplyr2.custom_summaries #> NULL #>  #> $tplyr2.scipen #> [1] 9999"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"ibm-rounding","dir":"Articles","previous_headings":"","what":"IBM Rounding","title":"tplyr2 Options","text":"R uses “banker’s rounding” (round half even) default. means 0.5 rounds 0, 1.5 rounds 2, 2.5 rounds 2, 3.5 rounds 4. rule minimizes cumulative bias large datasets, match SAS many statistical software packages round. clinical trial reporting, often need reproduce SAS output exactly. SAS uses round-half-away--zero (sometimes called “IBM rounding”), 2.5 always rounds 3 -2.5 always rounds -3. tplyr2 supports IBMRounding option. formula used IBM rounding enabled : round(x)=sign(x)⋅⌊|x|⋅10d+0.5⌋/10d\\text{round}(x) = \\text{sign}(x) \\cdot \\left\\lfloor |x| \\cdot 10^d + 0.5 \\right\\rfloor / 10^d Let’s see difference practice. build simple descriptive statistics table compare mean rounding methods. Banker’s rounding (default) IBM rounding (round-half-away--zero) difference subtle consequential regulatory submissions. mean falls exactly rounding boundary (e.g., 4.0 one decimal rounds “4.0” either way, values like 2.25 rounded one decimal show difference), IBM rounding consistently rounds 5 away zero, banker’s rounding alternates based preceding digit.","code":"# Create data where rounding makes a visible difference demo_data <- data.frame(   TRT = rep(c(\"Drug\", \"Placebo\"), each = 4),   VAL = c(2.5, 3.5, 4.5, 5.5, 1.5, 2.5, 3.5, 4.5) )  spec <- tplyr_spec(   cols = \"TRT\",   layers = tplyr_layers(     group_desc(\"VAL\",       settings = layer_settings(         format_strings = list(           \"Mean\" = f_str(\"x.x\", \"mean\")         )       )     )   ) )  # Default: banker's rounding result_bankers <- tplyr_build(spec, demo_data) kable(result_bankers[, !grepl(\"^ord\", names(result_bankers))],       caption = \"Banker's rounding (default)\") # IBM rounding tplyr2_options(IBMRounding = TRUE)  result_ibm <- tplyr_build(spec, demo_data) kable(result_ibm[, !grepl(\"^ord\", names(result_ibm))],       caption = \"IBM rounding (round-half-away-from-zero)\") # Reset to default tplyr2_options(IBMRounding = FALSE)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"quantile-algorithm","dir":"Articles","previous_headings":"","what":"Quantile Algorithm","title":"tplyr2 Options","text":"R’s quantile() function supports nine different algorithms, numbered Type 1 Type 9. default R Type 7, uses linear interpolation widely used statistics. However, SAS’s PROC UNIVARIATE uses algorithm closest R’s Type 3, selects nearest even order statistic. tplyr2, quantile_type option controls algorithm used q1, q3, iqr descriptive statistics layers. Quantile Type 7 (R default) Quantile Type 3 (SAS-compatible) differences Type 7 Type 3 tend small large datasets, can meaningful small groups exact SAS reconciliation required. statistical analysis plan (SAP) specifies SAS-compatible quantiles, set quantile_type = 3 start session.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"Q1, Q3\"  = f_str(\"xx.xx, xx.xx\", \"q1\", \"q3\"),           \"IQR\"     = f_str(\"xx.xx\", \"iqr\")         )       )     )   ) )  # Type 7 (R default) result_t7 <- tplyr_build(spec, tplyr_adsl) kable(result_t7[, !grepl(\"^ord\", names(result_t7))],       caption = \"Quantile Type 7 (R default)\") # Type 3 (SAS-compatible) tplyr2_options(quantile_type = 3)  result_t3 <- tplyr_build(spec, tplyr_adsl) kable(result_t3[, !grepl(\"^ord\", names(result_t3))],       caption = \"Quantile Type 3 (SAS-compatible)\") # Reset to default tplyr2_options(quantile_type = 7)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"precision-cap","dir":"Articles","previous_headings":"","what":"Precision Cap","title":"tplyr2 Options","text":"using tplyr2’s auto-precision system (format strings characters), integer decimal widths determined dynamically data. useful format must accommodate variables different scales, sometimes data can drive widths impractical extremes – variable recorded six decimal places produce wide columns. precision_cap option lets set global ceiling auto-precision widths. takes named numeric vector int /dec components. Auto-precision, cap Auto-precision, capped int=3, dec=1 Note precision_cap option serves global default. specific layer provides precision_cap layer_settings(), layer-level cap takes priority. gives safety net session level allowing individual layers override needed.","code":"# Without a cap, precision is driven entirely by the data spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"WEIGHTBL\",       by = \"Weight (kg)\",       settings = layer_settings(         format_strings = list(           \"Mean (SD)\" = f_str(\"a+1.a+1 (a+2.a+2)\", \"mean\", \"sd\")         )       )     )   ) )  result_nocap <- tplyr_build(spec, tplyr_adsl) kable(result_nocap[, !grepl(\"^ord\", names(result_nocap))],       caption = \"Auto-precision, no cap\") # Apply a global cap: max 3 integer digits, max 1 decimal digit tplyr2_options(precision_cap = c(int = 3, dec = 1))  result_capped <- tplyr_build(spec, tplyr_adsl) kable(result_capped[, !grepl(\"^ord\", names(result_capped))],       caption = \"Auto-precision, capped at int=3, dec=1\") # Reset to default tplyr2_options(precision_cap = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"custom-summaries","dir":"Articles","previous_headings":"","what":"Custom Summaries","title":"tplyr2 Options","text":"Descriptive statistics layers tplyr2 come set built-summaries (n, mean, sd, median, var, min, max, iqr, q1, q3, missing). study requires additional statistics across many tables – geometric means, coefficients variation, derived measure – can register session level available everywhere. things keep mind custom summaries: expression uses .var placeholder target variable’s values within group. build time, .var replaced actual numeric vector. Expressions wrapped quote() delay evaluation. expression throws error particular group (e.g., trying log() non-positive values), tplyr2 catches error returns NA_real_ rather stopping build. Session-level custom summaries can overridden layer-level custom_summaries layer_settings(). means can set study-wide defaults still customize individual layers. custom summary can even share name built-statistic (e.g., mean), case replaces built-calculation.","code":"# Register session-level custom summaries tplyr2_options(   custom_summaries = list(     geo_mean = quote(exp(mean(log(.var[.var > 0]), na.rm = TRUE))),     cv       = quote(sd(.var, na.rm = TRUE) / mean(.var, na.rm = TRUE) * 100)   ) )  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"              = f_str(\"xx\", \"n\"),           \"Mean (SD)\"      = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Geometric Mean\" = f_str(\"xx.xx\", \"geo_mean\"),           \"CV (%)\"         = f_str(\"xx.x\", \"cv\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))]) # Reset to default tplyr2_options(custom_summaries = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"scientific-notation-control","dir":"Articles","previous_headings":"","what":"Scientific Notation Control","title":"tplyr2 Options","text":"R may format large small numbers scientific notation (e.g., 1e+05 instead 100000). controlled R’s scipen option, sets penalty scientific notation – higher values make less likely. tplyr_build(), tplyr2 temporarily overrides scipen prevent scientific notation appearing formatted output. default value 9999 effectively guarantees scientific notation never appear tables. cases, need change . However, specific reason allow scientific notation (debugging formatting), can adjust : scipen override applied duration tplyr_build() automatically restored previous value build completes. means affect code session.","code":"# Check the current value tplyr2_options()$tplyr2.scipen #> [1] 9999"},{"path":"https://github.com/mstackhouse/tplyr2/articles/options.html","id":"resetting-options","dir":"Articles","previous_headings":"","what":"Resetting Options","title":"tplyr2 Options","text":"return options defaults, set one explicitly: tplyr2 options stored standard R options (tplyr2. prefix), reset automatically start new R session. want options persist, place tplyr2_options() call project’s .Rprofile top analysis script.","code":"tplyr2_options(   IBMRounding     = FALSE,   quantile_type   = 7L,   precision_cap   = NULL,   custom_summaries = NULL,   scipen          = 9999L )  # Verify tplyr2_options() #> $tplyr2.IBMRounding #> [1] FALSE #>  #> $tplyr2.quantile_type #> [1] 7 #>  #> $tplyr2.precision_cap #> NULL #>  #> $tplyr2.custom_summaries #> NULL #>  #> $tplyr2.scipen #> [1] 9999"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Post-Processing","text":"tplyr_build() produces data.frame rowlabel*, res*, ord_layer_* columns. output complete correct, yet ready polished report. Row labels still repeat across consecutive rows. Multiple label columns need collapsing one. depending output format, leading whitespace may need special handling. tplyr2 provides set post-processing functions transform build output display-ready tables. vignette walks , starting common operations ending utility functions targeted tasks.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"building-the-example-data","dir":"Articles","previous_headings":"","what":"Building the Example Data","title":"Post-Processing","text":"use multi-layer table throughout vignette effect post-processing step visible. spec combines demographics count layer descriptive statistics layer age. Notice rowlabel1 repeats across rows within grouping, two layers stacked without visual separation. post-processing functions address issues.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       by = c(label(\"Disposition\"), \"EOSSTT\"),       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"n\", \"pct\")         )       )     ),     group_desc(\"AGE\",       by = label(\"Age (years)\"),       settings = layer_settings(         format_strings = list(           \"Mean (SD)\" = f_str(\"xxx.x (xxx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xxx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xxx, xxx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 12))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"row-masks","dir":"Articles","previous_headings":"","what":"Row Masks","title":"Post-Processing","text":"apply_row_masks() walks rowlabel* column top--bottom blanks value identical row . deduplication respects layer boundaries, label appears end one layer beginning another never accidentally blanked.","code":"masked <- apply_row_masks(result) kable(head(masked[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 12))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"adding-row-breaks-between-layers","dir":"Articles","previous_headings":"Row Masks","what":"Adding Row Breaks Between Layers","title":"Post-Processing","text":"row_breaks = TRUE, blank row inserted every layer boundary. Combined masking, gives table clean, sectioned appearance.","code":"masked_breaks <- apply_row_masks(result, row_breaks = TRUE) kable(head(masked_breaks[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"res2\", \"res3\")], 14))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"collapsing-row-labels","dir":"Articles","previous_headings":"","what":"Collapsing Row Labels","title":"Post-Processing","text":"Many display formats expect single row label column rather separate rowlabel1, rowlabel2, etc. collapse_row_labels() takes specified columns collapses one column. Repeating parent values split rows, nesting level receives progressively indentation. columns collapse provided character strings (least two required). indent parameter accepts string — repeated nesting level. output column name defaults \"row_label\" can changed via target_col.","code":"collapsed <- collapse_row_labels(result, \"rowlabel1\", \"rowlabel2\", indent = \"   \") kable(head(collapsed[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 12))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"extracting-numeric-values","dir":"Articles","previous_headings":"","what":"Extracting Numeric Values","title":"Post-Processing","text":"Formatted tplyr2 strings like \"  5 ( 6.1%)\" useful display, sometimes need underlying numbers programmatic comparisons, sorting, conditional formatting. str_extract_num() pulls Nth numeric value string. function handles negative numbers, decimals, missing values gracefully. returns NA requested index exceeds number numeric values cell.","code":"# Extract the count (first number) from the first result column counts <- str_extract_num(result$res1, index = 1) head(counts, 8) #> [1]  0 58  0  0  0  0  0  0  # Extract the percentage (second number) pcts <- str_extract_num(result$res1, index = 2) head(pcts, 8) #> [1]  0.0 67.4  0.0  0.0  0.0  0.0  0.0  0.0"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"conditional-formatting","dir":"Articles","previous_headings":"","what":"Conditional Formatting","title":"Post-Processing","text":"apply_conditional_format() allows conditionally re-format string numbers based numeric value within string . selecting “format group” (targeting specific number within string, numbered left right), can establish condition upon replacement string used. Either replacement can replace entire string, can refill just format group preserving original width alignment. format_group parameter selects numeric value string evaluate (1st number, 2nd number, etc.). condition expression using variable name x tests selected number. full_string = FALSE (default), replacement padded preserve column alignment within format group’s character space.","code":"string <- c(\" 0  (0.0%)\", \" 8  (9.3%)\", \"78 (90.7%)\")  # Replace the full string when the percentage (2nd format group) is 0 apply_conditional_format(string, 2, x == 0, \" 0        \", full_string = TRUE) #> [1] \" 0        \" \" 8  (9.3%)\" \"78 (90.7%)\"  # Replace within the format group when the percentage is less than 1 apply_conditional_format(string, 2, x < 1, \"(<1%)\") #> [1] \" 0   (<1%)\" \" 8  (9.3%)\" \"78 (90.7%)\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"replacing-leading-whitespace","dir":"Articles","previous_headings":"","what":"Replacing Leading Whitespace","title":"Post-Processing","text":"tplyr2 uses leading spaces align numbers within format fields. works fixed-width contexts (PDFs, monospaced fonts), HTML collapses consecutive spaces. replace_leading_whitespace() swaps leading space non-breaking space (\\u00a0), preserving alignment web-based output. replace_with parameter defaults \"\\u00a0\" can set string. example, might use \"&nbsp;\" raw HTML output.","code":"original <- c(\"  5 ( 6.1%)\", \" 12 (14.6%)\", \"  3 ( 3.7%)\") replaced <- replace_leading_whitespace(original)  # Show the difference (non-breaking spaces are invisible but present) nchar(original) #> [1] 11 11 11 nchar(replaced) #> [1] 11 11 11"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"standalone-format-application","dir":"Articles","previous_headings":"","what":"Standalone Format Application","title":"Post-Processing","text":"apply_formats() function engine behind tplyr2’s string formatting, can also used . Given f_str object matching numeric vectors, returns formatted character strings. useful need format numbers external data sources using format strings drive tplyr2 tables. precision system also available precision parameter auto-precision formatting.","code":"fmt <- f_str(\"xxx.x (xxx.xx)\", \"mean\", \"sd\") apply_formats(fmt, c(75.3, 68.1, 80.5), c(8.21, 7.55, 9.03)) #> [1] \" 75.3 (  8.21)\" \" 68.1 (  7.55)\" \" 80.5 (  9.03)\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"text-wrapping","dir":"Articles","previous_headings":"","what":"Text Wrapping","title":"Post-Processing","text":"str_indent_wrap() wraps long text strings specified width automatically preserving existing indentation applying hyphenation words exceed column width. function automatically detects leading whitespace element preserves wrapped continuation lines. Long words exceed column width split hyphens. Tabs converted spaces using tab_width parameter (default 5).","code":"ex_text <- c(\"RENAL AND URINARY DISORDERS\", \"   NEPHROLITHIASIS\") cat(paste(str_indent_wrap(ex_text, width = 8), collapse = \"\\n\\n\"), \"\\n\") #> RENAL #> AND #> URINARY #> DISORDE- #> RS #>  #>    NEPHROL- #>    ITHIASI- #>    S"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting It All Together","title":"Post-Processing","text":"practice, chain several post-processing steps together. complete pipeline takes raw build output produces display-ready table. combining apply_row_masks() collapse_row_labels(), note collapse_row_labels() inserts stub rows removes original label columns, typically replaces need apply_row_masks(). deeply nested tables (3+ label columns), applying apply_row_masks() raw output first can still useful.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         total_row = TRUE,         total_row_label = \"Any adverse event\"       )     )   ) )  output <- tplyr_build(spec, tplyr_adae)  # Post-processing pipeline display <- output |>   collapse_row_labels(\"rowlabel1\", \"rowlabel2\", indent = \"   \")  kable(head(display[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 20))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"adding-conditional-formatting-to-the-pipeline","dir":"Articles","previous_headings":"Putting It All Together","what":"Adding Conditional Formatting to the Pipeline","title":"Post-Processing","text":"can apply conditional formatting result columns collapsing labels. replace percentage (<1%) placebo arm percentage rounds 0 count non-zero.","code":"# Apply conditional formatting before collapsing labels output$res1 <- apply_conditional_format(   output$res1, 2, x == 0, \"(<1%)\" )  display_formatted <- output |>   collapse_row_labels(\"rowlabel1\", \"rowlabel2\", indent = \"   \")  kable(head(display_formatted[, c(\"row_label\", \"res1\", \"res2\", \"res3\")], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/post_processing.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Post-Processing","text":"post-processing functions tplyr2 serve distinct purposes designed work together: typical pipeline runs apply_row_masks() first, collapse_row_labels(). Conditional formatting whitespace replacement can inserted wherever make sense output format.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Risk Difference","text":"clinical trials, adverse event tables typically display frequency events treatment group. counts informative , regulatory reviewers study teams often want see direct statistical comparison groups – specifically, difference proportions confidence interval around difference. quantity risk difference. risk difference answers straightforward question: much (less) likely event one group compared another? risk difference 10% 95% confidence interval (2%, 18%) tells event rate 10 percentage points higher treatment group, can reasonably confident true difference falls 2 18 percentage points. tplyr2 computes risk differences using stats::prop.test() continuity correction, producing asymptotic Wald-type confidence interval. configured entirely risk_diff parameter layer_settings(), results appear additional columns output alongside standard count summaries.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"basic-risk-difference","dir":"Articles","previous_headings":"","what":"Basic Risk Difference","title":"Risk Difference","text":"add risk difference count layer, pass risk_diff list inside layer_settings(). minimum, need specify two treatment levels compare via comparisons parameter. risk difference appears rdiff1 column. comparison pair specify produces one rdiff column, numbered sequentially. column carries label attribute indicating groups compared. Note order comparison pair matters: first element treatment group second reference. risk difference computed treatment proportion minus reference proportion, expressed percentage.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\"))         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"rdiff1\")], 10)) attr(result$rdiff1, \"label\") #> [1] \"Xanomeline High Dose vs Placebo\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"configuring-comparisons","dir":"Articles","previous_headings":"","what":"Configuring Comparisons","title":"Risk Difference","text":"limited single comparison. study multiple active dose groups, often want compare one placebo. Pass multiple pairs comparisons list. first comparison (Xanomeline High Dose vs Placebo) goes rdiff1, second (Xanomeline Low Dose vs Placebo) goes rdiff2. column gets label.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         risk_diff = list(           comparisons = list(             c(\"Xanomeline High Dose\", \"Placebo\"),             c(\"Xanomeline Low Dose\", \"Placebo\")           ),           format = f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"rdiff1\", \"rdiff2\")], 8)) attr(result$rdiff1, \"label\") #> [1] \"Xanomeline High Dose vs Placebo\" attr(result$rdiff2, \"label\") #> [1] \"Xanomeline Low Dose vs Placebo\""},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"formatting-output","dir":"Articles","previous_headings":"","what":"Formatting Output","title":"Risk Difference","text":"risk difference format controlled format parameter, takes f_str() object just like count format strings. Four variables available use format: rdiff – risk difference percentage lower – lower bound confidence interval upper – upper bound confidence interval p_value – p-value prop.test() format specified, tplyr2 uses default: f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\"). can include p-value formatted string table requires . x characters format string control field width, just count format strings. x reserves one character position, xx.x gives one decimal place room two-digit integer part. can adjust precision match table shell requirements.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\")),           format = f_str(\"xx.x (xx.x, xx.x) [x.xxxx]\", \"rdiff\", \"lower\", \"upper\", \"p_value\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"rdiff1\")], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"confidence-interval-level","dir":"Articles","previous_headings":"","what":"Confidence Interval Level","title":"Risk Difference","text":"default, tplyr2 computes 95% confidence interval. can change ci parameter. 90% interval narrower 95% interval data. confidence level choose match study’s statistical analysis plan.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\")),           ci = 0.90,           format = f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"rdiff1\")], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"risk-difference-with-distinct-counts","dir":"Articles","previous_headings":"","what":"Risk Difference with Distinct Counts","title":"Risk Difference","text":"Risk difference calculations naturally work distinct_by setting. distinct_by specified, proportions used risk difference based distinct subject counts rather event counts. almost always want adverse event tables, single subject can contribute multiple events. output, count columns show distinct subjects, percentage, total event count brackets. risk difference computed distinct subject proportions, clinically meaningful comparison.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%) [xxx]\", \"distinct_n\", \"distinct_pct\", \"n\")         ),         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\")),           format = f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"rdiff1\")], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"interaction-with-special-rows","dir":"Articles","previous_headings":"","what":"Interaction with Special Rows","title":"Risk Difference","text":"important detail: risk differences computed special rows (total rows missing rows) appended. means total missing rows empty risk difference values, expected behavior – risk difference total row meaningful. “adverse event” row empty rdiff1 value total row added risk difference computation.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         total_row = TRUE,         total_row_label = \"Any adverse event\",         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\")),           format = f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) # Show the last few rows including the total row tail_rows <- tail(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"rdiff1\")], 5) kable(tail_rows)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"extracting-raw-numbers","dir":"Articles","previous_headings":"","what":"Extracting Raw Numbers","title":"Risk Difference","text":"formatted risk difference strings useful display, sometimes need underlying numeric values analysis custom formatting. tplyr_numeric_data() function gives access raw counts used compute risk differences. data.frame contains raw counts, percentages, denominators per treatment group preferred term. values feed prop.test() calls. can also extract numeric values directly formatted risk difference strings using str_extract_num(). function pulls nth number formatted string. approach useful need numeric risk difference values downstream tasks like sorting, filtering, creating forest plots.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(\"AEDECOD\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         ),         risk_diff = list(           comparisons = list(c(\"Xanomeline High Dose\", \"Placebo\")),           format = f_str(\"xx.x (xx.x, xx.x)\", \"rdiff\", \"lower\", \"upper\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) nd <- tplyr_numeric_data(result, layer = 1) kable(head(nd, 10)) # Extract the risk difference value (1st number) result$rdiff_value <- str_extract_num(result$rdiff1, 1)  # Extract the lower CI bound (2nd number) result$rdiff_lower <- str_extract_num(result$rdiff1, 2)  # Extract the upper CI bound (3rd number) result$rdiff_upper <- str_extract_num(result$rdiff1, 3)  kable(head(result[, c(\"rowlabel1\", \"rdiff1\", \"rdiff_value\", \"rdiff_lower\", \"rdiff_upper\")], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/riskdiff.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Risk Difference","text":"Risk difference tplyr2 configured entirely risk_diff parameter layer_settings(). key points remember: Comparisons specified pairs treatment levels, first element treatment second reference. Multiple comparisons produce separate rdiff column (rdiff1, rdiff2, etc.). Formatting uses f_str() variables rdiff, lower, upper, p_value. Confidence level defaults 0.95 adjustable via ci parameter. Risk differences computed special rows (total, missing), rows empty risk difference values. Raw count data accessible tplyr_numeric_data(), formatted values can parsed str_extract_num().","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spec Serialization","text":"One central design principles tplyr2 separation specification data. tplyr_spec() object describes table contain – column structure, layers, formatting rules – without touching actual dataset. Data supplied build time via tplyr_build(spec, data). separation creates natural opportunity: spec pure configuration, can saved file loaded back later. tplyr2 supports serializing specs JSON YAML formats. opens several practical workflows: Version control: Specs stored JSON YAML plain text, integrate naturally Git. can track changes table definitions alongside analysis code. Portability: spec file can shared team members across studies. recipient loads builds data. Reproducibility: Archiving spec alongside output creates clear record exactly configuration produced given table. Regulatory submissions: machine-readable table definition can serve supporting documentation submission package.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"writing-a-spec-to-json","dir":"Articles","previous_headings":"","what":"Writing a Spec to JSON","title":"Spec Serialization","text":"tplyr_write_spec() function takes spec object file path. format determined file extension: use .json JSON output. file now plain-text JSON document. Let’s verify can read back build table.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   layers = tplyr_layers(     group_count(\"SEX\", by = \"Sex n (%)\"),     group_desc(       \"AGE\",       by = \"Age (Years)\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  json_path <- tempfile(fileext = \".json\") tplyr_write_spec(spec, json_path)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"reading-a-spec-back","dir":"Articles","previous_headings":"","what":"Reading a Spec Back","title":"Spec Serialization","text":"tplyr_read_spec() function reads spec JSON YAML file reconstructs full tplyr_spec object, including expressions, format strings, layer configurations. loaded spec functionally identical original. can build dataset required columns. output get building original spec directly. round-trip – write disk, read back, build – preserves everything.","code":"loaded_spec <- tplyr_read_spec(json_path) loaded_spec #> tplyr2 table specification #> Column variables: TRT01PWhere: SAFFL == \"Y\"Layers: 2[1] count: SEX (Layer 1)[2] desc: AGE (Layer 2) result <- tplyr_build(loaded_spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"yaml-format","dir":"Articles","previous_headings":"","what":"YAML Format","title":"Spec Serialization","text":"prefer YAML JSON, simply use .yaml .yml file extension. API identical. YAML tends readable human review, JSON widely supported automated tools. choice matter preference; tplyr2 handles transparently.","code":"yaml_path <- tempfile(fileext = \".yaml\") tplyr_write_spec(spec, yaml_path)  yaml_spec <- tplyr_read_spec(yaml_path) yaml_result <- tplyr_build(yaml_spec, tplyr_adsl)  # Confirm the results match identical(   result[, !grepl(\"^ord\", names(result))],   yaml_result[, !grepl(\"^ord\", names(yaml_result))] ) #> [1] TRUE"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"what-gets-serialized","dir":"Articles","previous_headings":"","what":"What Gets Serialized","title":"Spec Serialization","text":"tplyr_spec can contain several types R objects direct equivalents JSON YAML. serialization system handles one specific convention.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"expressions","dir":"Articles","previous_headings":"What Gets Serialized","what":"Expressions","title":"Spec Serialization","text":"Filter expressions like = SAFFL == \"Y\" R language objects. serialized deparsing expression string wrapping marker object. JSON, clause looks like : deserialization, string parsed back R expression using rlang::parse_expr(). preserves original filter logic exactly.","code":"{   \"where\": {     \"_expr\": \"SAFFL == \\\"Y\\\"\"   } }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"format-strings","dir":"Articles","previous_headings":"What Gets Serialized","what":"Format Strings","title":"Spec Serialization","text":"f_str() objects stored component parts: format template, variable names, optional empty parameter. marker class field (_class: \"tplyr_f_str\") identifies reconstruction. read back, f_str() constructor called components, re-parsing format string rebuilding internal structure.","code":"{   \"format_string\": \"xx.x (xx.xx)\",   \"vars\": [\"mean\", \"sd\"],   \"_class\": \"tplyr_f_str\" }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"labels-in-by","dir":"Articles","previous_headings":"What Gets Serialized","what":"Labels in by","title":"Spec Serialization","text":"use label() parameter create explicit text label, label serialized type marker can distinguished data variable name. Regular data variable names (character strings) pass -.","code":"{   \"value\": \"Age (Years)\",   \"_type\": \"label\" }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"functions","dir":"Articles","previous_headings":"What Gets Serialized","what":"Functions","title":"Spec Serialization","text":"Analyze layers created group_analyze() include user-defined function. serialized deparsing function body string. deserialization, string parsed evaluated recreate function object. Note functions depend objects specific environment (closures capture external variables) may survive round-trip. best results, write analyze functions self-contained.","code":"{   \"_fn\": \"function(.data, .target_var) {\\n  ...\\n}\" }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"examining-the-serialized-output","dir":"Articles","previous_headings":"","what":"Examining the Serialized Output","title":"Spec Serialization","text":"Let’s look actual JSON content produced earlier spec see conventions practice. can see structure: top-level cols fields, followed layers array. layer carries target_var, , , layer_type, settings. Within settings, format_strings contains serialized f_str objects.","code":"json_content <- readLines(json_path) cat(json_content, sep = \"\\n\") #> { #>   \"cols\": \"TRT01P\", #>   \"where\": { #>     \"_expr\": \"SAFFL == \\\"Y\\\"\" #>   }, #>   \"layers\": [ #>     { #>       \"target_var\": \"SEX\", #>       \"by\": \"Sex n (%)\", #>       \"where\": null, #>       \"layer_type\": \"count\", #>       \"settings\": { #>         \"indentation\": \"  \", #>         \"total_row\": false, #>         \"total_row_label\": \"Total\", #>         \"total_row_count_missings\": true, #>         \"missing_subjects\": false, #>         \"missing_subjects_label\": \"Missing\", #>         \"stats_as_columns\": false #>       } #>     }, #>     { #>       \"target_var\": \"AGE\", #>       \"by\": \"Age (Years)\", #>       \"where\": null, #>       \"layer_type\": \"desc\", #>       \"settings\": { #>         \"format_strings\": { #>           \"n\": { #>             \"format_string\": \"xxx\", #>             \"vars\": \"n\", #>             \"_class\": \"tplyr_f_str\" #>           }, #>           \"Mean (SD)\": { #>             \"format_string\": \"xx.x (xx.xx)\", #>             \"vars\": [\"mean\", \"sd\"], #>             \"_class\": \"tplyr_f_str\" #>           }, #>           \"Median\": { #>             \"format_string\": \"xx.x\", #>             \"vars\": \"median\", #>             \"_class\": \"tplyr_f_str\" #>           }, #>           \"Min, Max\": { #>             \"format_string\": \"xx, xx\", #>             \"vars\": [\"min\", \"max\"], #>             \"_class\": \"tplyr_f_str\" #>           } #>         }, #>         \"indentation\": \"  \", #>         \"total_row\": false, #>         \"total_row_label\": \"Total\", #>         \"total_row_count_missings\": true, #>         \"missing_subjects\": false, #>         \"missing_subjects_label\": \"Missing\", #>         \"stats_as_columns\": false #>       } #>     } #>   ] #> }"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"a-more-complex-example","dir":"Articles","previous_headings":"","what":"A More Complex Example","title":"Spec Serialization","text":"Let’s serialize spec exercises system: nested counts distinct counting, clause, total row. Now read back build. total group, total row, multi-target descriptive layer, formatting survive round-trip.","code":"complex_spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   total_groups = list(total_group(\"TRT01P\", label = \"Total\")),   layers = tplyr_layers(     group_count(       \"RACE\",       by = \"Race n (%)\",       settings = layer_settings(         total_row = TRUE,         total_row_label = \"Total\"       )     ),     group_desc(       c(\"AGE\", \"WEIGHTBL\"),       by = \"Baseline Measurements\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Min, Max\"  = f_str(\"xx.x, xx.x\", \"min\", \"max\")         )       )     )   ) )  complex_path <- tempfile(fileext = \".json\") tplyr_write_spec(complex_spec, complex_path) reloaded <- tplyr_read_spec(complex_path) complex_result <- tplyr_build(reloaded, tplyr_adsl) kable(complex_result[, !grepl(\"^ord\", names(complex_result))])"},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"version-controlled-table-definitions","dir":"Articles","previous_headings":"Use Cases","what":"Version-Controlled Table Definitions","title":"Spec Serialization","text":"Storing specs JSON YAML files project repository means every change table definition tracked. reviewer asks “changed draft final version Table 14.1?”, can answer question git diff spec file. spec file plain-text artifact reviewers can inspect without running R.","code":"# In your analysis script spec <- tplyr_read_spec(\"specs/table_14_1.json\") result <- tplyr_build(spec, adsl)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"sharing-across-teams","dir":"Articles","previous_headings":"Use Cases","what":"Sharing Across Teams","title":"Spec Serialization","text":"statistician can define table structure save spec. programmer different system can load build study data. spec travels lightweight file rather R object requires specific environment.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"applying-a-spec-to-different-data","dir":"Articles","previous_headings":"Use Cases","what":"Applying a Spec to Different Data","title":"Spec Serialization","text":"specs carry data, spec can applied datasets different studies, time points, populations. useful standardized tables appear across multiple studies.","code":"# Same spec, different data subsets saffl_result <- tplyr_build(loaded_spec, tplyr_adsl[tplyr_adsl$SAFFL == \"Y\", ]) ittfl_result <- tplyr_build(loaded_spec, tplyr_adsl[tplyr_adsl$ITTFL == \"Y\", ])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/serialization.html","id":"regulatory-archival","dir":"Articles","previous_headings":"Use Cases","what":"Regulatory Archival","title":"Spec Serialization","text":"regulatory submissions, archiving machine-readable table definition alongside analysis output provides additional layer documentation. JSON YAML file describes exactly table configured, format require R interpret.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Shift Layers","text":"Shift tables common display clinical trial reporting. summarize change categorical state one time point another – often, change laboratory normal range indicator baseline post-baseline visit. rows shift table represent “” state (e.g., baseline normal range: Low, Normal, High), columns represent “” state (e.g., post-baseline normal range). cell contains count percentage subjects moved one category another. tables give reviewers quick, matrix-style view treatment affects lab values relative reference ranges. tplyr2, shift tables built group_shift(). hood, shift layer abstraction count layer. reuses much counting formatting code, “column” dimension shift variable folded result columns alongside treatment variable. means result column represents treatment--shift-category combination, “Placebo | Normal” “Xanomeline High Dose | High”. design, shift layers limitations compared count layers: nesting (single-variable shifts) total rows missing subject rows risk difference result-based sorting shift table needs, limitations concern. need text-style shift display (e.g., rows reading “Low High”, “Normal High”), standard group_count() layer better fit.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"a-basic-example","dir":"Articles","previous_headings":"","what":"A Basic Example","title":"Shift Layers","text":"demonstrate shift layers, create small example dataset mimics typical laboratory analysis dataset baseline post-baseline normal range indicators. data hand, building shift table straightforward. key difference count layer target_var argument: instead single string, pass named character vector elements \"row\" \"column\". \"row\" element identifies variable defines row categories (“” state), \"column\" identifies variable produces additional column groups (“” state). things notice output: rowlabel1 rowlabel2 columns populated variables (PARAM, VISIT), rowlabel3 contains values row shift variable (BNRIND). result column represents treatment--ANRIND combination. column labels (stored attributes) follow pattern \"Treatment | ANRIND (N=n)\". default format \"xx (xx.x%)\", showing count percentage, default used count layers. However, may notice BNRIND values present output whatever happened appear data. category like “L” (Low) appear data, absent table entirely. Similarly, sort order rows depends alphabetical order character values. problems solution: factors.","code":"set.seed(42)  # Create example shift data adlb <- data.frame(   USUBJID = rep(paste0(\"SUBJ-\", sprintf(\"%03d\", 1:30)), each = 2),   TRTA    = rep(rep(c(\"Placebo\", \"Xanomeline High Dose\", \"Xanomeline Low Dose\"),                      each = 10), each = 2),   PARAM   = rep(c(\"Creatine Kinase\", \"Alkaline Phosphatase\"), times = 30),   PARAMCD = rep(c(\"CK\", \"ALP\"), times = 30),   VISIT   = \"WEEK 24\",   BNRIND  = sample(c(\"N\", \"H\"), 60, replace = TRUE, prob = c(0.7, 0.3)),   ANRIND  = sample(c(\"N\", \"H\"), 60, replace = TRUE, prob = c(0.5, 0.5)),   stringsAsFactors = FALSE ) spec <- tplyr_spec(   cols = \"TRTA\",   where = PARAMCD == \"CK\",   layers = tplyr_layers(     group_shift(       c(row = \"BNRIND\", column = \"ANRIND\"),       by = c(\"PARAM\", \"VISIT\")     )   ) )  result <- tplyr_build(spec, adlb) kable(result[, !grepl(\"^ord_\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"filling-missing-groups-using-factors","dir":"Articles","previous_headings":"","what":"Filling Missing Groups Using Factors","title":"Shift Layers","text":"R, factor variables carry two important pieces information: set allowable levels order. convert shift variables factors building table, tplyr2 uses factor levels : Complete table – levels appear rows (columns), even zero counts. Control sort order – rows follow order factor levels, alphabetical order. especially important shift tables, standard presentation order typically Low, Normal, High. Now table includes three levels – L, N, H – rows column groups, regardless whether subjects actually fell categories. Cells observations display \" 0 (  0.0%)\", maintaining consistent alignment. rows also follow factor level order (L, N, H) rather alphabetical order (H, L, N). pattern using factors control completeness ordering applies broadly across tplyr2, particularly important shift tables matrix structure must complete interpretable.","code":"# Convert to factors with the desired level order adlb$BNRIND <- factor(adlb$BNRIND, levels = c(\"L\", \"N\", \"H\")) adlb$ANRIND <- factor(adlb$ANRIND, levels = c(\"L\", \"N\", \"H\"))  spec <- tplyr_spec(   cols = \"TRTA\",   where = PARAMCD == \"CK\",   layers = tplyr_layers(     group_shift(       c(row = \"BNRIND\", column = \"ANRIND\"),       by = c(\"PARAM\", \"VISIT\"),       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xx (xxx.x%)\", \"n\", \"pct\")         )       )     )   ) )  result <- tplyr_build(spec, adlb) kable(result[, !grepl(\"^ord_\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"customizing-the-format","dir":"Articles","previous_headings":"","what":"Customizing the Format","title":"Shift Layers","text":"Like count layers, shift layers accept format strings layer_settings(). can display just counts, just percentages, combination. format string system one used across tplyr2.","code":"# Counts only spec_counts <- tplyr_spec(   cols = \"TRTA\",   where = PARAMCD == \"CK\",   layers = tplyr_layers(     group_shift(       c(row = \"BNRIND\", column = \"ANRIND\"),       by = c(\"PARAM\", \"VISIT\"),       settings = layer_settings(         format_strings = list(           n_counts = f_str(\"xx\", \"n\")         )       )     )   ) )  result_counts <- tplyr_build(spec_counts, adlb) kable(result_counts[, !grepl(\"^ord_\", names(result_counts))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"one-thing-to-note","dir":"Articles","previous_headings":"","what":"One Thing to Note","title":"Shift Layers","text":"group_shift() API designed specifically matrix-style shift tables, baseline categories form rows post-baseline categories form columns. cross-tabulation style common shift table format clinical reporting. However, shift displays take form. Sometimes may need text-based summary row describes specific transition, “Low High” “Normal Normal”. style display, group_count() right tool. create derived variable data concatenates baseline post-baseline values (e.g., paste(BNRIND, \"\", ANRIND)) count variable directly.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/shift.html","id":"where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Where to Go From Here","title":"Shift Layers","text":"Shift layers share much underlying machinery count layers, many concepts count layer documentation apply well. reading: denominator vignette covers denominators computed customize , directly affects percentages displayed shift tables. sorting ordering vignette explains row column ordering works, including role factor levels touched vignette.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sorting a tplyr2 Table","text":"build table tplyr_build(), output includes set ordering columns alongside formatted results. columns – ord_layer_index, ord_layer_1, ord_layer_2, – carry sorting information tplyr2 computed build. exist can re-sort, interleave, rearrange output fact without losing track intended presentation order. vignette explains ordering columns mean, tplyr2 decides values, can control get row order need.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"ordering-columns-explained","dir":"Articles","previous_headings":"","what":"Ordering Columns Explained","title":"Sorting a tplyr2 Table","text":"Every output tplyr_build() includes least two ordering columns: ord_layer_index: integer identifying layer produced row. first layer spec gets index 1, second gets index 2, . ord_layer_1: numeric sort key ordering rows within layer. count layers reflects target variable’s sort position; desc layers reflects order statistics format_strings list. Nested count layers add second within-layer ordering column, ord_layer_2, tracks nesting depth. Additional variables may produce ordering columns. Let’s see simple example. rows sorted alphabetically values DCDECOD, ord_layer_1 captures alphabetical position. ord_layer_index 1 every row one layer.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"ord_layer_index\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"sorting-across-layers","dir":"Articles","previous_headings":"","what":"Sorting Across Layers","title":"Sorting a tplyr2 Table","text":"spec contains multiple layers, ord_layer_index keeps right order. Consider table combines count layer descriptive statistics layer. count layer rows ord_layer_index = 1 desc layer rows ord_layer_index = 2. wanted flip layers descriptive statistics appear first, can sort ord_layer_index custom order:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\"),     group_desc(\"AGE\",       by = \"Age (years)\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"ord_layer_index\", \"ord_layer_1\")]) # Swap layer order: desc first, then counts result$sort_key <- ifelse(result$ord_layer_index == 2, 1, 2) reordered <- result[order(result$sort_key, result$ord_layer_1), ] kable(reordered[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"ord_layer_index\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"sorting-by-variable-values","dir":"Articles","previous_headings":"","what":"Sorting by Variable Values","title":"Sorting a tplyr2 Table","text":"Within layer, tplyr2 determines row order using priority system implemented internal compute_var_order() function. priority : Factor levels – target variable factor, rows follow factor’s level order. VARN companion columns – data contains numeric companion column (e.g., RACEN RACE), values used sort keys. Alphabetical – neither applies, rows sorted alphabetically.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"factor-level-ordering","dir":"Articles","previous_headings":"Sorting by Variable Values","what":"Factor Level Ordering","title":"Sorting a tplyr2 Table","text":"target variable factor, tplyr2 uses level order. gives direct control row sequence. order_count_method = \"byfactor\", ord_layer_1 maps factor level position: COMPLETED level 1, ADVERSE EVENT level 2, . get rows factor-level order, sort ord_layer_1.","code":"adsl <- tplyr_adsl adsl$DCDECOD <- factor(adsl$DCDECOD, levels = c(   \"COMPLETED\",   \"ADVERSE EVENT\",   \"WITHDRAWAL BY SUBJECT\",   \"PHYSICIAN DECISION\",   \"STUDY TERMINATED BY SPONSOR\",   \"LACK OF EFFICACY\",   \"PROTOCOL VIOLATION\",   \"LOST TO FOLLOW-UP\",   \"DEATH\" ))  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         order_count_method = \"byfactor\"       )     )   ) )  result <- tplyr_build(spec, adsl) sorted <- result[order(result$ord_layer_1), ] kable(sorted[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"varn-companion-column-ordering","dir":"Articles","previous_headings":"Sorting by Variable Values","what":"VARN Companion Column Ordering","title":"Sorting a tplyr2 Table","text":"CDISC datasets often include numeric companion columns encode preferred sort order. example, RACEN provides numeric key RACE. tplyr2 detects column named <VAR>N data, uses values automatically. , RACEN values 1 (WHITE), 2 (BLACK AFRICAN AMERICAN), 6 (AMERICAN INDIAN ALASKA NATIVE) drive sort keys ord_layer_1.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\",       settings = layer_settings(         order_count_method = \"byvarn\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) sorted <- result[order(result$ord_layer_1), ] kable(sorted[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"sorting-descriptive-statistics","dir":"Articles","previous_headings":"","what":"Sorting Descriptive Statistics","title":"Sorting a tplyr2 Table","text":"group_desc() layers, ord_layer_1 reflects position statistic within format_strings list. first entry gets 1, second gets 2, forth. additional setting needed – order write format strings order rows appear. want “Median” appear “Mean (SD)”, simply move earlier format_strings list.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\"),           \"Q1, Q3\"     = f_str(\"xx.x, xx.x\", \"q1\", \"q3\"),           \"Min, Max\"   = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"sorting-count-layers","dir":"Articles","previous_headings":"","what":"Sorting Count Layers","title":"Sorting a tplyr2 Table","text":"Count layers offer flexibility order_count_method parameter layer_settings(). available methods : order_count_method left NULL (default), tplyr2 auto-detects: checks factor levels first, VARN companions, falls back alphabetical.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"sorting-by-count","dir":"Articles","previous_headings":"Sorting Count Layers","what":"Sorting by Count","title":"Sorting a tplyr2 Table","text":"\"bycount\" method sorts rows count values descending order, common adverse event tables frequent events appear first. using \"bycount\", ord_layer_1 contains negated count values (lower values sort first descending order).","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         order_count_method = \"bycount\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) sorted <- result[order(result$ord_layer_1), ] kable(sorted[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"controlling-which-column-drives-the-sort","dir":"Articles","previous_headings":"Sorting Count Layers","what":"Controlling Which Column Drives the Sort","title":"Sorting a tplyr2 Table","text":"sorting count, may want sort based specific treatment column rather columns. ordering_cols parameter lets specify column level use deriving sort counts, result_order_var specifies statistic sort (defaulting \"n\").","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"DCDECOD\",       settings = layer_settings(         order_count_method = \"bycount\",         ordering_cols = \"Placebo\",         result_order_var = \"n\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) sorted <- result[order(result$ord_layer_1), ] kable(sorted[, c(\"rowlabel1\", \"res1\", \"res2\", \"res3\", \"ord_layer_1\")])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"nested-count-sorting","dir":"Articles","previous_headings":"","what":"Nested Count Sorting","title":"Sorting a tplyr2 Table","text":"Nested count layers – created passing two variables group_count() – produce interleaved output outer-level rows (e.g., body system) alternate inner-level rows (e.g., preferred term). ordering system handles levels. nested output: ord_layer_1 captures row sequence within interleaved structure. ord_layer_2 indicates nesting depth: 1 outer-level (body system) rows, 2 inner-level (preferred term) rows. Total rows, present, get depth 0. outer_sort_position parameter layer_settings() controls sort direction outer-level groupings, accepting \"asc\" \"desc\".","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", \"res1\", \"ord_layer_index\",                        \"ord_layer_1\", \"ord_layer_2\")], 12))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/sort.html","id":"practical-example-preparing-a-final-table","dir":"Articles","previous_headings":"","what":"Practical Example: Preparing a Final Table","title":"Sorting a tplyr2 Table","text":"practice, ordering columns tools use post-processing. ready produce final display table, typically sort data using ord_layer_* columns drop rendering. ordering columns gave us full control row sequence. sorting, strip away final table shows content columns. pattern – build, sort, drop – standard workflow preparing tplyr2 output display export.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\",       by = \"Race\",       settings = layer_settings(         order_count_method = \"byvarn\"       )     ),     group_desc(\"AGE\",       by = \"Age (years)\",       settings = layer_settings(         format_strings = list(           \"n\"          = f_str(\"xx\", \"n\"),           \"Mean (SD)\"  = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"     = f_str(\"xx.x\", \"median\"),           \"Min, Max\"   = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl)  # Sort by layer index, then within-layer order result <- result[order(result$ord_layer_index, result$ord_layer_1), ]  # Drop ordering columns for display display_cols <- !grepl(\"^ord_\", names(result)) kable(result[, display_cols])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Table Properties","text":"tplyr2, table defined specification. tplyr_spec() function captures full configuration – column variables, filters, treatment groups, population data, layers – pure description want. data processing happens call tplyr_build(). vignette covers spec-level parameters control overall structure table. Every tplyr2 workflow follows two steps: define spec tplyr_spec(), build table tplyr_build(spec, data). Let’s look example using included tplyr_adsl dataset. Note cols parameter defines column structure output. unique value TRT01P becomes result column, column labels automatically include group count (N=xx).","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(target_var = \"SEX\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"column-variables","dir":"Articles","previous_headings":"","what":"Column Variables","title":"Table Properties","text":"cols parameter accepts character vector one variable names define columns output table. common case single treatment variable:","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(target_var = \"AGEGR1\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"multiple-column-variables","dir":"Articles","previous_headings":"Column Variables","what":"Multiple Column Variables","title":"Table Properties","text":"provide multiple variables, tplyr2 creates cross combinations. useful need columns split treatment another variable. Notice column labels use \" | \" separator show cross treatment sex, combination gets N.","code":"spec <- tplyr_spec(   cols = c(\"TRT01P\", \"SEX\"),   layers = tplyr_layers(     group_count(target_var = \"AGEGR1\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"table-level-filtering-with-where","dir":"Articles","previous_headings":"","what":"Table-Level Filtering with where","title":"Table Properties","text":"parameter applies filter data layer processing begins. useful records excluded entire table. count descriptive statistics layers computed safety population. Individual layers can also filters, applied addition table-level filter.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   layers = tplyr_layers(     group_count(target_var = \"AGEGR1\", by = \"Age Group\"),     group_desc(       target_var = \"AGE\",       by = \"Age (Years)\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", \"rowlabel2\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"treatment-groups","dir":"Articles","previous_headings":"","what":"Treatment Groups","title":"Table Properties","text":"Clinical tables often need columns beyond individual treatment arms. tplyr2 provides total groups custom groups purpose.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"total-groups","dir":"Articles","previous_headings":"Treatment Groups","what":"Total Groups","title":"Table Properties","text":"total group creates synthetic column includes subjects duplicating every row column variable set total group label. “Total” column now appears alongside individual treatment arms, N reflecting sum subjects.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   total_groups = list(     total_group(\"TRT01P\", label = \"Total\")   ),   layers = tplyr_layers(     group_count(target_var = \"SEX\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"custom-groups","dir":"Articles","previous_headings":"Treatment Groups","what":"Custom Groups","title":"Table Properties","text":"Custom groups combine specific treatment levels new group. example, might pool two active dose groups together. “Xanomeline” column includes subjects dose groups, original dose-level columns preserved.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   custom_groups = list(     custom_group(       \"TRT01P\",       \"Xanomeline\" = c(\"Xanomeline High Dose\", \"Xanomeline Low Dose\")     )   ),   layers = tplyr_layers(     group_count(target_var = \"SEX\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"combining-total-and-custom-groups","dir":"Articles","previous_headings":"Treatment Groups","what":"Combining Total and Custom Groups","title":"Table Properties","text":"can use together. Custom groups applied first, total groups duplicate rows (including custom group rows). means “Total” column include subjects custom group well.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   custom_groups = list(     custom_group(       \"TRT01P\",       \"Xanomeline\" = c(\"Xanomeline High Dose\", \"Xanomeline Low Dose\")     )   ),   total_groups = list(     total_group(\"TRT01P\", label = \"Total\")   ),   layers = tplyr_layers(     group_count(target_var = \"SEX\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"population-data","dir":"Articles","previous_headings":"","what":"Population Data","title":"Table Properties","text":"many clinical analyses, denominators header Ns come different dataset analysis data. classic example adverse event table: ADAE contains subjects experienced events, percentages reflect full safety population ADSL. pop_data() configuration specifies population dataset maps spec. actual data provided build time. things note: cols = \"TRTA\" matches treatment variable ADAE. pop_data(cols = c(\"TRTA\" = \"TRT01A\")) maps TRT01A population data TRTA analysis data (format: c(\"analysis_name\" = \"pop_name\")). distinct_by = \"USUBJID\" counts subject per body system. Denominators column Ns come full tplyr_adsl population.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(cols = c(\"TRTA\" = \"TRT01A\")),   layers = tplyr_layers(     group_count(       target_var = \"AEBODSYS\",       settings = layer_settings(         distinct_by = \"USUBJID\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl) kable(head(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))], 8))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"extracting-header-n","dir":"Articles","previous_headings":"Population Data","what":"Extracting Header N","title":"Table Properties","text":"building table population data, can extract header N values using tplyr_header_n(): useful need programmatically construct column headers integrate reporting tools.","code":"header_n <- tplyr_header_n(result) kable(header_n)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"population-data-with-filters","dir":"Articles","previous_headings":"Population Data","what":"Population Data with Filters","title":"Table Properties","text":"population data subject spec-level filter. uses clause, specified pop_data() call: separation intentional. table-level controls records summarized, pop_data controls subjects contribute denominators. practice often differ – might filter AE records treatment-emergent events basing denominators full safety population.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(     cols = c(\"TRTA\" = \"TRT01A\"),     where = SAFFL == \"Y\"   ),   layers = tplyr_layers(     group_count(       target_var = \"AEBODSYS\",       settings = layer_settings(         distinct_by = \"USUBJID\"       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl) kable(tplyr_header_n(result))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"data-completion","dir":"Articles","previous_headings":"","what":"Data Completion","title":"Table Properties","text":"building count layers, tplyr2 automatically completes combinations factor levels cross-variables. treatment group zero subjects given characteristic, 0 (0.0%) row still appears rather dropped. Every race category appears every treatment group, even count zero.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(target_var = \"RACE\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, c(\"rowlabel1\", grep(\"^res\", names(result), value = TRUE))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"limiting-completion-with-limit_data_by","dir":"Articles","previous_headings":"Data Completion","what":"Limiting Completion with limit_data_by","title":"Table Properties","text":"Sometimes completing combinations aggressive. limit_data_by parameter layer_settings() restricts completion grid combinations actually exist data. essential AE tables preferred terms appear actual body system: limit_data_by = c(\"AEBODSYS\", \"AEDECOD\"), tplyr2 creates rows body system/preferred term combinations exist data, still filling zeros treatment groups events given combination.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   pop_data = pop_data(cols = c(\"TRTA\" = \"TRT01A\")),   layers = tplyr_layers(     group_count(       target_var = \"AEDECOD\",       by = \"AEBODSYS\",       settings = layer_settings(         distinct_by = \"USUBJID\",         limit_data_by = c(\"AEBODSYS\", \"AEDECOD\")       )     )   ) )  result <- tplyr_build(spec, tplyr_adae, pop_data = tplyr_adsl) kable(head(result[, c(\"rowlabel1\", \"rowlabel2\", grep(\"^res\", names(result), value = TRUE))], 10))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/table.html","id":"where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Where to Go From Here","title":"Table Properties","text":"vignette covered table-level properties control overall structure tplyr2 output. details specific layer types additional features, see: Count layers: group_count() frequency tables, including nested counts, distinct subject counts, missing value handling Descriptive statistics layers: group_desc() summary statistics format strings, auto-precision, custom summary functions Shift layers: group_shift() baseline--post-baseline cross-tabulations Ordering: tplyr2 sorts rows controls output order Options: Package-level options via tplyr2_options()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"how-tplyr2-works","dir":"Articles","previous_headings":"","what":"How tplyr2 Works","title":"Getting Started with tplyr2","text":"worked clinical data long enough, know summary tables – demographics tables, adverse event tables, lab shift tables – share common structural pattern. section table represents kind summary: set counts, block descriptive statistics, cross-tabulation. tplyr2 built around idea. Rather writing bespoke data manipulation code every table, describe table contain using declarative specification, tplyr2 handles computing, formatting, assembly. key concepts : Spec: tplyr_spec() object pure configuration. describes column structure, global filters, list layers. data processing happens create spec. Layers: layer one summary block. Count layers (group_count()) produce frequencies. Descriptive layers (group_desc()) compute means, medians, summaries. Shift layers (group_shift()) create cross-tabulations. Custom layers (group_analyze()) accept user-defined functions. Build: tplyr_build(spec, data) executes spec dataset returns formatted data frame. separation configuration execution intentional. spec can saved disk, reviewed, reused across studies, applied different datasets build time. familiar PHUSE Analyses & Displays White Paper, layer model maps naturally summary blocks described .","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"the-tplyr_spec-object","dir":"Articles","previous_headings":"","what":"The tplyr_spec() Object","title":"Getting Started with tplyr2","text":"Every table starts tplyr_spec(). minimum, need column variable (typically treatment arm) least one layer. cols parameter determines variable defines output columns. unique value becomes result column. function also accepts optional parameters: : global filter expression (e.g., = SAFFL == \"Y\"). pop_data: pop_data() configuration population-based denominators. total_groups: list total_group() objects “Total” columns. custom_groups: list custom_group() objects combined treatment arms. layers: Layer objects wrapped tplyr_layers(). spec contains data. Data supplied build time, spec can reused across datasets.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\"),     group_desc(\"AGE\")   ) ) spec #> tplyr2 table specification #> Column variables: TRT01PLayers: 2[1] count: SEX (Layer 1)[2] desc: AGE (Layer 2)"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"the-tplyr_layer-object","dir":"Articles","previous_headings":"","what":"The tplyr_layer() Object","title":"Getting Started with tplyr2","text":"Layers building blocks tplyr2 table. create group_*() family: group_count(), group_desc(), group_shift(), group_analyze(). Every layer constructor accepts: target_var: variable(s) summarized. : Optional row grouping. Strings matching column names become grouping variables; strings become text labels output. Use label() explicit disambiguation. : optional layer-level filter expression. settings: layer_settings() object detailed configuration. Multiple layers collected tplyr_layers(): Layers processed order stacked vertically output.","code":"layers <- tplyr_layers(   group_count(\"SEX\", by = \"Sex n (%)\"),   group_count(\"RACE\", by = \"Race n (%)\"),   group_desc(\"AGE\", by = \"Age (Years)\") )"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"building-a-table","dir":"Articles","previous_headings":"","what":"Building a Table","title":"Getting Started with tplyr2","text":"spec dataset, building single function call. Let’s look demographics-style table count descriptive layers: output standard data frame. columns mean: rowlabel1, rowlabel2, …: Row label columns. label adds one column; data variable adds another; target variable adds one . res1, res2, …: Result columns, one per unique level cols. carries label attribute column name , population data available, (N=n) suffix. ord_layer_index, ord_layer_1, …: Ordering columns sorting. can dropped display useful programmatic reordering.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   where = SAFFL == \"Y\",   layers = tplyr_layers(     group_count(\"SEX\", by = \"Sex n (%)\"),     group_desc(       \"AGE\",       by = \"Age (Years)\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"string-formatting-in-tplyr2","dir":"Articles","previous_headings":"","what":"String Formatting in tplyr2","title":"Getting Started with tplyr2","text":"One important features tplyr2 format string system. Clinical tables specific alignment precision requirements. f_str() function lets declare exactly numbers appear. f_str() two parts: template string defines layout, variable names map template’s format groups. format group sequence x characters (optional decimal point) determines width precision. number x characters integer part sets total width (including leading spaces alignment). Characters decimal point set decimal precision. Everything format groups literal text. descriptive statistics layers, format strings named list. name becomes row label. Built-statistics available : n, mean, sd, median, var, min, max, iqr, q1, q3, missing, pct, total. count layers, format string uses n, pct, distinct_n, distinct_pct: format source variables declared together, package knows exactly numbers produced cell – foundation metadata traceability system.","code":"# Two decimal places for mean, two for SD, with parentheses f_str(\"xx.xx (xx.xx)\", \"mean\", \"sd\") #> tplyr format string: \"xx.xx (xx.xx)\"Variables: mean, sd  # Integer count only f_str(\"xxx\", \"n\") #> tplyr format string: \"xxx\"Variables: n  # Count with percentage f_str(\"xx (xx.x%)\", \"n\", \"pct\") #> tplyr format string: \"xx (xx.x%)\"Variables: n, pct # n (pct%) -- the default f_str(\"xx (xx.x%)\", \"n\", \"pct\")  # Distinct count and percentage f_str(\"xx (xx.x%)\", \"distinct_n\", \"distinct_pct\")"},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"descriptive-statistics-layers","dir":"Articles","previous_headings":"Layer Types","what":"Descriptive Statistics Layers","title":"Getting Started with tplyr2","text":"Descriptive statistics layers summarize continuous variables. Without custom format strings, default produces six rows: n, Mean (SD), Median, Q1/Q3, Min/Max, Missing.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(\"AGE\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"multiple-target-variables","dir":"Articles","previous_headings":"Layer Types > Descriptive Statistics Layers","what":"Multiple Target Variables","title":"Getting Started with tplyr2","text":"need summarize one variable layer – example, Age Average Daily Dose – pass vector names target_var. variable gets block rows, variable name additional row label.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_desc(       c(\"AGE\", \"AVGDD\"),       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"count-layers","dir":"Articles","previous_headings":"Layer Types","what":"Count Layers","title":"Getting Started with tplyr2","text":"Count layers tabulate frequency categorical variable levels. default, produce counts percentages formatted \"xx (xx.x%)\":","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"RACE\")   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"total-rows","dir":"Articles","previous_headings":"Layer Types > Count Layers","what":"Total Rows","title":"Getting Started with tplyr2","text":"total row sums counts across levels. Enable total_row = TRUE layer_settings():","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(       \"RACE\",       settings = layer_settings(total_row = TRUE)     )   ) )  result <- tplyr_build(spec, tplyr_adsl) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"distinct-counting","dir":"Articles","previous_headings":"Layer Types > Count Layers","what":"Distinct Counting","title":"Getting Started with tplyr2","text":"adverse event tables, often need count number subjects experienced event, number event records. Use distinct_by specify subject identifier:","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(       \"AEBODSYS\",       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"nested-counts","dir":"Articles","previous_headings":"Layer Types > Count Layers","what":"Nested Counts","title":"Getting Started with tplyr2","text":"Many clinical tables require hierarchical counts – example, adverse events body system preferred term. Pass vector variable names target_var: outer level (body system) appears rowlabel1, inner level (preferred term) appears indented rowlabel2. Outer rows contain aggregate counts body system; inner rows contain per-term counts. Indentation defaults two spaces can changed via indentation parameter layer_settings().","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(       c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) kable(head(result[, !grepl(\"^ord\", names(result))], 15))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"shift-layers","dir":"Articles","previous_headings":"Layer Types","what":"Shift Layers","title":"Getting Started with tplyr2","text":"Shift tables display cross-tabulation baseline value post-baseline value within treatment arm. group_shift() function requires named character vector row column elements: output, rowlabel1 contains baseline (row) variable values, result columns represent combination treatment arm post-baseline (column) level. Factor ordering respected, setting levels appropriately (e.g., c(\"LOW\", \"NORMAL\", \"HIGH\")) ensures intended display order.","code":"set.seed(12345) shift_data <- data.frame(   USUBJID = paste0(\"SUBJ\", 1:30),   TRTA = rep(c(\"Placebo\", \"Active\"), each = 15),   BNRIND = factor(     sample(c(\"LOW\", \"NORMAL\", \"HIGH\"), 30, replace = TRUE, prob = c(0.2, 0.6, 0.2)),     levels = c(\"LOW\", \"NORMAL\", \"HIGH\")   ),   ANRIND = factor(     sample(c(\"LOW\", \"NORMAL\", \"HIGH\"), 30, replace = TRUE, prob = c(0.15, 0.5, 0.35)),     levels = c(\"LOW\", \"NORMAL\", \"HIGH\")   ) )  spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_shift(       c(row = \"BNRIND\", column = \"ANRIND\"),       settings = layer_settings(         format_strings = list(n_counts = f_str(\"xxx\", \"n\"))       )     )   ) )  result <- tplyr_build(spec, shift_data) kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"numeric-data","dir":"Articles","previous_headings":"","what":"Numeric Data","title":"Getting Started with tplyr2","text":"Formatted cells look good final report, sometimes need raw numbers – validation, computation, archiving. Every tplyr2 build retains unformatted numeric data attribute. Use tplyr_numeric_data() retrieve : gives exact counts, percentages, means, every computed statistic raw numeric form, keyed grouping variables used build.","code":"spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\"),     group_desc(       \"AGE\",       settings = layer_settings(         format_strings = list(           \"n\" = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl)  # Raw numeric data for the count layer (layer 1) kable(tplyr_numeric_data(result, layer = 1)) # Raw numeric data for the desc layer (layer 2) kable(tplyr_numeric_data(result, layer = 2))"},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Where to Go from Here","title":"Getting Started with tplyr2","text":"vignette covers fundamentals. topics covered vignettes: vignette(\"count\") – Denominator control, missing value handling, risk differences, ordering. vignette(\"desc\") – Custom summaries, auto-precision, stats--columns. vignette(\"shift\") – Shift layers cross-tabulation options. vignette(\"denom\") – Population data, header N, total groups, custom groups. vignette(\"post_processing\") – Row masks, row label collapsing, conditional formatting, text wrapping. vignette(\"metadata\") – Cell-level metadata traceability. vignette(\"serialization\") – Saving loading specs JSON YAML. vignette(\"analyze\") – Custom analysis layers user-defined functions.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/articles/tplyr2.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting Started with tplyr2","text":"PHUSE Analyses & Displays White Paper – Demographics, Disposition, Medications CDISC Analysis Data Model (ADaM)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mike Stackhouse. Author, maintainer.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Stackhouse M (2026). tplyr2: Grammar Clinical Summary Tables. R package version 0.1.0.9000.","code":"@Manual{,   title = {tplyr2: A Grammar of Clinical Summary Tables},   author = {Mike Stackhouse},   year = {2026},   note = {R package version 0.1.0.9000}, }"},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"tplyr2","dir":"","previous_headings":"","what":"A Grammar of Clinical Summary Tables","title":"A Grammar of Clinical Summary Tables","text":"{tplyr2} grammar clinical summary tables. Clinical reports – demographics tables, adverse event summaries, lab shift tables – share common structural pattern. section kind summary: set counts, block descriptive statistics, cross-tabulation. Rather writing bespoke data manipulation code every table, {tplyr2} lets describe table contain using declarative specification, handles computing, formatting, assembly . {tplyr2} ground-rewrite {Tplyr}, built data.table performance. spec-based API separates configuration data, making specs portable, reusable, serializable JSON/YAML.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Grammar of Clinical Summary Tables","text":"can install development version {tplyr2} GitHub:","code":"# install.packages(\"devtools\") devtools::install_github(\"atorus-research/tplyr2\")"},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"A Grammar of Clinical Summary Tables","text":"Every table starts tplyr_spec() declares column structure layers. Data supplied build time tplyr_build().","code":"library(tplyr2)  spec <- tplyr_spec(   cols = \"TRT01P\",   layers = tplyr_layers(     group_count(\"SEX\", by = \"Sex n (%)\"),     group_desc(       \"AGE\",       by = \"Age (Years)\",       settings = layer_settings(         format_strings = list(           \"n\"         = f_str(\"xxx\", \"n\"),           \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\"),           \"Median\"    = f_str(\"xx.x\", \"median\"),           \"Min, Max\"  = f_str(\"xx, xx\", \"min\", \"max\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adsl) knitr::kable(result[, !grepl(\"^ord\", names(result))])"},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"key-concepts","dir":"","previous_headings":"","what":"Key Concepts","title":"A Grammar of Clinical Summary Tables","text":"Spec: tplyr_spec() object pure configuration – data, side effects. describes column variable, filters, population data, layers. Layers: layer summary block created group_count(), group_desc(), group_shift(), group_analyze(). Build: tplyr_build(spec, data) executes spec dataset returns formatted data frame. Format strings: f_str() declarations control numeric precision alignment (e.g., f_str(\"xx.x (xx.xx)\", \"mean\", \"sd\")).","code":""},{"path":[]},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"count-layers","dir":"","previous_headings":"Layer Types","what":"Count Layers","title":"A Grammar of Clinical Summary Tables","text":"Tabulate frequencies categorical variables, support nested counts, distinct subject counting, total rows.","code":"spec <- tplyr_spec(   cols = \"TRTA\",   layers = tplyr_layers(     group_count(       c(\"AEBODSYS\", \"AEDECOD\"),       settings = layer_settings(         distinct_by = \"USUBJID\",         format_strings = list(           n_counts = f_str(\"xxx (xx.x%)\", \"distinct_n\", \"distinct_pct\")         )       )     )   ) )  result <- tplyr_build(spec, tplyr_adae) knitr::kable(head(result[, !grepl(\"^ord\", names(result))], 10))"},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"descriptive-statistics-layers","dir":"","previous_headings":"Layer Types","what":"Descriptive Statistics Layers","title":"A Grammar of Clinical Summary Tables","text":"Summarize continuous variables built-statistics (n, mean, sd, median, min, max, q1, q3, var, iqr, missing) custom summary functions.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"shift-layers","dir":"","previous_headings":"Layer Types","what":"Shift Layers","title":"A Grammar of Clinical Summary Tables","text":"Cross-tabulate baseline value post-baseline value within treatment arm using group_shift().","code":""},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"analyze-layers","dir":"","previous_headings":"Layer Types","what":"Analyze Layers","title":"A Grammar of Clinical Summary Tables","text":"Run user-defined analysis functions group_analyze() full flexibility.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"A Grammar of Clinical Summary Tables","text":"Population data: Control denominators pop_data() display (N=n) header counts tplyr_header_n() Total & custom groups: Add “Total” columns combine treatment arms total_group() custom_group() Auto-precision: Dynamically set decimal places based collected precision precision cap system Risk difference: Compute risk differences confidence intervals count layers Post-processing: Row masks, row label collapsing, conditional formatting, text wrapping helpers Metadata: Cell-level traceability trace result back source records Numeric data: Access raw unformatted results via tplyr_numeric_data() Serialization: Save load specs JSON YAML tplyr_write_spec() / tplyr_read_spec() ARD: Convert Analysis Results Data format tplyr_to_ard() / tplyr_from_ard()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/index.html","id":"learning-more","dir":"","previous_headings":"","what":"Learning More","title":"A Grammar of Clinical Summary Tables","text":"vignette(\"tplyr2\") – Getting started vignette(\"count\") – Count layers depth vignette(\"desc\") – Descriptive statistics layers vignette(\"shift\") – Shift layers vignette(\"denom\") – Population data, header N, total custom groups vignette(\"general_string_formatting\") – Format string system vignette(\"metadata\") – Cell-level metadata traceability vignette(\"serialization\") – Saving loading specs vignette(\"analyze\") – Custom analyze layers vignette(\"post_processing\") – Post-processing helpers","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_conditional_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","title":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","text":"function allows conditionally re-format string numbers based numeric value within string . selecting \"format group\", targeting specific number within string, user can establish condition upon provided replacement string can used. Either entire replacement can used replace entire string, replacement text can refill \"format group\" preserving original width alignment target string.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_conditional_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","text":"","code":"apply_conditional_format(   string,   format_group,   condition,   replacement,   full_string = FALSE )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_conditional_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","text":"string Target character vector text may replaced format_group integer representing targeted numeric field within string, numbered left right condition expression, using variable name x target variable within condition replacement string use replacement value full_string TRUE full string replaced, FALSE replacement done within format group","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_conditional_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","text":"character vector","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_conditional_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional reformatting of a pre-populated string of numbers — apply_conditional_format","text":"","code":"string <- c(\" 0  (0.0%)\", \" 8  (9.3%)\", \"78 (90.7%)\")  apply_conditional_format(string, 2, x == 0, \" 0        \", full_string = TRUE) #> [1] \" 0        \" \" 8  (9.3%)\" \"78 (90.7%)\"  apply_conditional_format(string, 2, x < 1, \"(<1%)\") #> [1] \" 0   (<1%)\" \" 8  (9.3%)\" \"78 (90.7%)\""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_custom_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply custom column groups to data — apply_custom_groups","title":"Apply custom column groups to data — apply_custom_groups","text":"Duplicates rows matching source levels column variable set custom group name.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_custom_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply custom column groups to data — apply_custom_groups","text":"","code":"apply_custom_groups(dt, custom_groups)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_custom_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply custom column groups to data — apply_custom_groups","text":"dt data.table custom_groups List tplyr_custom_group objects (NULL)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_custom_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply custom column groups to data — apply_custom_groups","text":"Modified data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_formats.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply format strings to numeric values — apply_formats","title":"Apply format strings to numeric values — apply_formats","text":"Vectorized formatting function. Takes f_str object numeric vectors, returns character vector formatted strings.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_formats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply format strings to numeric values — apply_formats","text":"","code":"apply_formats(fmt, ..., precision = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_formats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply format strings to numeric values — apply_formats","text":"fmt f_str object character format string ... Numeric vectors, one per variable f_str (positional matching) precision Optional list resolved precision per group (auto-precision)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_formats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply format strings to numeric values — apply_formats","text":"Character vector formatted values","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_overrides.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply build-time overrides to a spec — apply_overrides","title":"Apply build-time overrides to a spec — apply_overrides","text":"Merges override parameters copy spec. Handles special cases: : character, parsed expression via rlang::parse_expr(). pop_data: list, sub-fields merged existing pop_data config rather replacing entirely.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_overrides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply build-time overrides to a spec — apply_overrides","text":"","code":"apply_overrides(spec, overrides)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_overrides.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply build-time overrides to a spec — apply_overrides","text":"spec tplyr_spec object overrides Named list override values","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_overrides.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply build-time overrides to a spec — apply_overrides","text":"Modified spec (shallow copy)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_precision_cap.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply precision caps — apply_precision_cap","title":"Apply precision caps — apply_precision_cap","text":"Applies layer-level cap first, falls back global option.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_precision_cap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply precision caps — apply_precision_cap","text":"","code":"apply_precision_cap(prec, precision_cap = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_precision_cap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply precision caps — apply_precision_cap","text":"prec data.table max_int max_dec columns precision_cap Named numeric vector c(int=, dec=) NULL","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_precision_cap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply precision caps — apply_precision_cap","text":"Modified data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_row_masks.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply row masks to blank repeated row labels — apply_row_masks","title":"Apply row masks to blank repeated row labels — apply_row_masks","text":"Walks rowlabel* column top--bottom blanks values identical previous row, respecting layer boundaries (ord_layer_index).","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_row_masks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply row masks to blank repeated row labels — apply_row_masks","text":"","code":"apply_row_masks(result, row_breaks = FALSE)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_row_masks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply row masks to blank repeated row labels — apply_row_masks","text":"result data.frame produced tplyr_build() row_breaks Logical. TRUE, insert blank row layers.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_row_masks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply row masks to blank repeated row labels — apply_row_masks","text":"data.frame repeated labels blanked","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_total_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply total groups to data — apply_total_groups","title":"Apply total groups to data — apply_total_groups","text":"Duplicates rows column variable set total group label, creating synthetic \"Total\" column level.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_total_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply total groups to data — apply_total_groups","text":"","code":"apply_total_groups(dt, total_groups)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_total_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply total groups to data — apply_total_groups","text":"dt data.table total_groups List tplyr_total_group objects (NULL)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/apply_total_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply total groups to data — apply_total_groups","text":"Modified data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a custom analysis layer — build_analyze_layer","title":"Process a custom analysis layer — build_analyze_layer","text":"Calls user-provided analyze_fn group combination formats results using either format_strings pre-formatted column.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a custom analysis layer — build_analyze_layer","text":"","code":"build_analyze_layer(dt, layer, cols, layer_index, col_n = NULL, pop_dt = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a custom analysis layer — build_analyze_layer","text":"dt data.table (filtered) input data layer tplyr_analyze_layer object cols Character vector column variable names spec layer_index Integer index layer col_n data.table column counts (NULL) pop_dt data.table population data (NULL)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a custom analysis layer — build_analyze_layer","text":"data.table rowlabel*, res*, ord* columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_row_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row label columns for analyze layer — build_analyze_row_labels","title":"Build row label columns for analyze layer — build_analyze_row_labels","text":"Build row label columns analyze layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_analyze_row_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row label columns for analyze layer — build_analyze_row_labels","text":"","code":"build_analyze_row_labels(combined, by_labels, by_data_vars)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_filter_exprs.html","id":null,"dir":"Reference","previous_headings":"","what":"Build filter expressions for a single output cell — build_cell_filter_exprs","title":"Build filter expressions for a single output cell — build_cell_filter_exprs","text":"Constructs complete set filter expressions one cell output table inspecting row's label values, column label, layer/spec configuration.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_filter_exprs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build filter expressions for a single output cell — build_cell_filter_exprs","text":"","code":"build_cell_filter_exprs(   output,   row_idx,   rc,   layer,   layer_idx,   cols,   col_level_map,   var_to_rl,   by_data_vars,   spec,   pop_col_map = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_filter_exprs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build filter expressions for a single output cell — build_cell_filter_exprs","text":"output output data.frame row_idx Row index output rc Result column name (e.g., \"res1\") layer tplyr_layer object layer_idx Integer layer index cols Character vector spec-level column variables col_level_map Named list: res column -> column variable level string var_to_rl Named list mapping data variables rowlabel columns by_data_vars Character vector -variable data column names spec tplyr_spec object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_filter_exprs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build filter expressions for a single output cell — build_cell_filter_exprs","text":"tplyr_meta object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Build cell-level metadata for the full output table — build_cell_metadata","title":"Build cell-level metadata for the full output table — build_cell_metadata","text":"output row x result column combination, constructs filter expressions describe source data subset cell. expressions can evaluated query time original data.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build cell-level metadata for the full output table — build_cell_metadata","text":"","code":"build_cell_metadata(output, spec, col_names, pop_col_map = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build cell-level metadata for the full output table — build_cell_metadata","text":"output data.frame output tplyr_build (rowlabel/res/ord cols) spec tplyr_spec object col_names Character vector original data column names","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_cell_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build cell-level metadata for the full output table — build_cell_metadata","text":"Named list tplyr_meta objects, keyed \"row_id||column\"","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_col_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Build column labels with header N suffix — build_col_labels","title":"Build column labels with header N suffix — build_col_labels","text":"Takes raw dcast column names col_n data.table, returns labels \"(N=)\" suffix. shift layers label includes spec-level cols shift column variable, spec-level portion used N lookup.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_col_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build column labels with header N suffix — build_col_labels","text":"","code":"build_col_labels(raw_labels, col_n)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_col_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build column labels with header N suffix — build_col_labels","text":"raw_labels Character vector raw column labels dcast col_n data.table spec-level column variables .n column, NULL (case labels returned unchanged)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_col_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build column labels with header N suffix — build_col_labels","text":"Character vector labels N suffix","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a count layer — build_count_layer","title":"Process a count layer — build_count_layer","text":"Process count layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a count layer — build_count_layer","text":"","code":"build_count_layer(dt, layer, cols, layer_index, col_n = NULL, pop_dt = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a count layer — build_count_layer","text":"dt data.table (filtered) input data layer tplyr_count_layer object cols Character vector column variable names spec layer_index Integer index layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a count layer — build_count_layer","text":"data.table rowlabel*, res*, ord* columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer_nested.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a nested (multi-variable) count layer — build_count_layer_nested","title":"Process a nested (multi-variable) count layer — build_count_layer_nested","text":"Process nested (multi-variable) count layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer_nested.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a nested (multi-variable) count layer — build_count_layer_nested","text":"","code":"build_count_layer_nested(   dt,   target_vars,   cols,   by_data_vars,   by_labels,   settings,   layer_index,   col_n = NULL,   pop_dt = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a single-variable count layer — build_count_layer_single","title":"Process a single-variable count layer — build_count_layer_single","text":"Process single-variable count layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_count_layer_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a single-variable count layer — build_count_layer_single","text":"","code":"build_count_layer_single(   dt,   tv,   cols,   by_data_vars,   by_labels,   settings,   layer_index,   col_n = NULL,   pop_dt = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a descriptive statistics layer — build_desc_layer","title":"Process a descriptive statistics layer — build_desc_layer","text":"Process descriptive statistics layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a descriptive statistics layer — build_desc_layer","text":"","code":"build_desc_layer(dt, layer, cols, layer_index, col_n = NULL, pop_dt = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a descriptive statistics layer — build_desc_layer","text":"dt data.table (filtered) input data layer tplyr_desc_layer object cols Character vector column variable names spec layer_index Integer index layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a descriptive statistics layer — build_desc_layer","text":"data.table rowlabel*, res*, ord* columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a multi-target desc layer — build_desc_multi","title":"Build a multi-target desc layer — build_desc_multi","text":"Build multi-target desc layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a multi-target desc layer — build_desc_multi","text":"","code":"build_desc_multi(   dt,   target_vars,   cols,   by_data_vars,   by_labels,   settings,   layer_index,   col_n,   pop_dt = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a single-target desc layer — build_desc_single","title":"Build a single-target desc layer — build_desc_single","text":"Build single-target desc layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_desc_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a single-target desc layer — build_desc_single","text":"","code":"build_desc_single(   dt,   tv,   cols,   by_data_vars,   by_labels,   settings,   layer_index,   col_n,   var_label = NULL,   var_index = NULL,   pop_dt = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_nested_row_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row labels for a nested count level — build_nested_row_labels","title":"Build row labels for a nested count level — build_nested_row_labels","text":"Build row labels nested count level","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_nested_row_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row labels for a nested count level — build_nested_row_labels","text":"","code":"build_nested_row_labels(   counts,   by_labels,   by_data_vars,   target_vars,   level,   n_levels,   indentation )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_nested_row_labels_special.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row labels for special rows (total/missing) in nested context — build_nested_row_labels_special","title":"Build row labels for special rows (total/missing) in nested context — build_nested_row_labels_special","text":"Build row labels special rows (total/missing) nested context","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_nested_row_labels_special.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row labels for special rows (total/missing) in nested context — build_nested_row_labels_special","text":"","code":"build_nested_row_labels_special(   dt,   by_labels,   by_data_vars,   target_vars,   tv,   n_label_cols )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_row_labels_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row label columns for count layers — build_row_labels_count","title":"Build row label columns for count layers — build_row_labels_count","text":"Build row label columns count layers","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_row_labels_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row label columns for count layers — build_row_labels_count","text":"","code":"build_row_labels_count(counts, by_labels, by_data_vars, tv)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_row_labels_special.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row labels for special rows (missing, total) in single-variable context — build_row_labels_special","title":"Build row labels for special rows (missing, total) in single-variable context — build_row_labels_special","text":"Build row labels special rows (missing, total) single-variable context","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_row_labels_special.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row labels for special rows (missing, total) in single-variable context — build_row_labels_special","text":"","code":"build_row_labels_special(dt, by_labels, by_data_vars, tv, existing_label_cols)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a shift layer — build_shift_layer","title":"Process a shift layer — build_shift_layer","text":"Builds cross-tabulation (row variable × column variable) within treatment arm. shift column variable becomes additional column dimension, producing result columns like \"Placebo_H\", \"Placebo_N\", etc.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a shift layer — build_shift_layer","text":"","code":"build_shift_layer(dt, layer, cols, layer_index, col_n = NULL, pop_dt = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a shift layer — build_shift_layer","text":"dt data.table (filtered) input data layer tplyr_shift_layer object cols Character vector column variable names spec layer_index Integer index layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a shift layer — build_shift_layer","text":"data.table rowlabel*, res*, ord* columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_row_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Build row labels for shift layer — build_shift_row_labels","title":"Build row labels for shift layer — build_shift_row_labels","text":"Build row labels shift layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_shift_row_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build row labels for shift layer — build_shift_row_labels","text":"","code":"build_shift_row_labels(counts, by_labels, by_data_vars, row_var)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_var_to_rowlabel_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Map data variable names to their rowlabel columns — build_var_to_rowlabel_map","title":"Map data variable names to their rowlabel columns — build_var_to_rowlabel_map","text":"Map data variable names rowlabel columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_var_to_rowlabel_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map data variable names to their rowlabel columns — build_var_to_rowlabel_map","text":"","code":"build_var_to_rowlabel_map(layer, by_data_vars, by_labels, col_names)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_var_to_rowlabel_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map data variable names to their rowlabel columns — build_var_to_rowlabel_map","text":"layer tplyr_layer object by_data_vars Character vector -variable data column names by_labels Character vector -variable label strings col_names Character vector original data column names","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/build_var_to_rowlabel_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map data variable names to their rowlabel columns — build_var_to_rowlabel_map","text":"Named list names data variables values rowlabel column names (e.g., list(SEX = \"rowlabel1\"))","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/call_analyze_fn_by_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Call analyze_fn for each group combination — call_analyze_fn_by_group","title":"Call analyze_fn for each group combination — call_analyze_fn_by_group","text":"Call analyze_fn group combination","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/call_analyze_fn_by_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call analyze_fn for each group combination — call_analyze_fn_by_group","text":"","code":"call_analyze_fn_by_group(dt, analyze_fn, target_var, group_vars)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/cast_to_wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast long data to wide output format — cast_to_wide","title":"Cast long data to wide output format — cast_to_wide","text":"Cast long data wide output format","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/cast_to_wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast long data to wide output format — cast_to_wide","text":"","code":"cast_to_wide(dt, row_label_cols, cols, layer_index, col_n = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify by values into data variables and labels — classify_by","title":"Classify by values into data variables and labels — classify_by","text":"Classify values data variables labels","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify by values into data variables and labels — classify_by","text":"","code":"classify_by(by, col_names)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_row_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify an output row as normal, total, missing, or missing_subjects — classify_row_type","title":"Classify an output row as normal, total, missing, or missing_subjects — classify_row_type","text":"Classify output row normal, total, missing, missing_subjects","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_row_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify an output row as normal, total, missing, or missing_subjects — classify_row_type","text":"","code":"classify_row_type(output, row_idx, layer, var_to_rl)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_row_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify an output row as normal, total, missing, or missing_subjects — classify_row_type","text":"output output data.frame row_idx Row index output layer tplyr_layer object var_to_rl Named list mapping data variables rowlabel columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/classify_row_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify an output row as normal, total, missing, or missing_subjects — classify_row_type","text":"Character string: \"normal\", \"total\", \"missing\", \"missing_subjects\"","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collapse_row_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse row labels into a single column — collapse_row_labels","title":"Collapse row labels into a single column — collapse_row_labels","text":"generalized post processing function allows take groups variables collapse single column. Repeating values split separate rows, level nesting, specified indentation level can applied.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collapse_row_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse row labels into a single column — collapse_row_labels","text":"","code":"collapse_row_labels(x, ..., indent = \"  \", target_col = \"row_label\")"},{"path":"https://github.com/mstackhouse/tplyr2/reference/collapse_row_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse row labels into a single column — collapse_row_labels","text":"x Input data frame ... Column names (character strings) collapsed, must 2 indent Indentation string used, multiplied indentation level target_col Character string naming output column containing collapsed row labels","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collapse_row_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collapse row labels into a single column — collapse_row_labels","text":"data.frame row labels collapsed single column","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collapse_row_labels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collapse row labels into a single column — collapse_row_labels","text":"","code":"x <- data.frame(   row_label1 = c(\"A\", \"A\", \"A\", \"B\", \"B\"),   row_label2 = c(\"C\", \"C\", \"D\", \"E\", \"F\"),   var1 = 1:5,   stringsAsFactors = FALSE )  collapse_row_labels(x, \"row_label1\", \"row_label2\") #>   row_label var1 #> 1         A   NA #> 2         C    1 #> 3         C    2 #> 4         D    3 #> 5         B   NA #> 6         E    4 #> 7         F    5  collapse_row_labels(x, \"row_label1\", \"row_label2\", indent = \"    \",                     target_col = \"rl\") #>      rl var1 #> 1     A   NA #> 2     C    1 #> 3     C    2 #> 4     D    3 #> 5     B   NA #> 6     E    4 #> 7     F    5"},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect precision from data — collect_precision","title":"Collect precision from data — collect_precision","text":"Scans numeric variable determine maximum integer width maximum decimal precision present data, optionally grouped.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect precision from data — collect_precision","text":"","code":"collect_precision(   dt,   precision_on,   precision_by = character(0),   precision_data = NULL,   precision_cap = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect precision from data — collect_precision","text":"dt data.table data precision_on Character string naming variable scan precision_by Character vector grouping variables (can empty) precision_data Optional external data.frame pre-computed precision precision_cap Named numeric vector c(int=, dec=) capping","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect precision from data — collect_precision","text":"data.table precision_by columns + \"max_int\" \"max_dec\" columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute max integer width and max decimal precision from a numeric vector — collect_precision_values","title":"Compute max integer width and max decimal precision from a numeric vector — collect_precision_values","text":"Compute max integer width max decimal precision numeric vector","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute max integer width and max decimal precision from a numeric vector — collect_precision_values","text":"","code":"collect_precision_values(vals)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute max integer width and max decimal precision from a numeric vector — collect_precision_values","text":"vals Numeric vector (already NA/Inf removed)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/collect_precision_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute max integer width and max decimal precision from a numeric vector — collect_precision_values","text":"list(max_int, max_dec)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete count data to ensure all combinations exist — complete_counts","title":"Complete count data to ensure all combinations exist — complete_counts","text":"Complete count data ensure combinations exist","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete count data to ensure all combinations exist — complete_counts","text":"","code":"complete_counts(   counts,   dt,   cols,   by_data_vars,   tv,   limit_data_by = NULL,   denom_group = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_nested_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete counts for a nested level — complete_nested_level","title":"Complete counts for a nested level — complete_nested_level","text":"Complete counts nested level","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_nested_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete counts for a nested level — complete_nested_level","text":"","code":"complete_nested_level(   counts,   dt,   cols,   by_data_vars,   level_tvs,   limit_data_by = NULL,   denom_group = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_shift_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete shift count data — complete_shift_counts","title":"Complete shift count data — complete_shift_counts","text":"Ensures row_var × col_var × cols combinations exist, filling missing combinations zero counts.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/complete_shift_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete shift count data — complete_shift_counts","text":"","code":"complete_shift_counts(   counts,   dt,   all_cols,   by_data_vars,   row_var,   denom_group = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_count_sort_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute sort keys for count layer rows — compute_count_sort_keys","title":"Compute sort keys for count layer rows — compute_count_sort_keys","text":"Computes ordering columns count layer's rows, based -variable target variable values.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_count_sort_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute sort keys for count layer rows — compute_count_sort_keys","text":"","code":"compute_count_sort_keys(counts, dt, cols, by_data_vars, tv, settings)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_count_sort_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute sort keys for count layer rows — compute_count_sort_keys","text":"counts data.table count data (long format, cast) dt data.table original input data (VARN lookup) cols Character vector spec column variables by_data_vars Character vector data variable names tv Character string, target variable name settings Layer settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_count_sort_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute sort keys for count layer rows — compute_count_sort_keys","text":"counts data.table .ord_by_* .ord_tv columns added","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute missing count row — compute_missing_counts","title":"Compute missing count row — compute_missing_counts","text":"Compute missing count row","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute missing count row — compute_missing_counts","text":"","code":"compute_missing_counts(   dt,   counts,   cols,   by_data_vars,   tv,   group_vars,   denom_group,   denom_dt,   distinct_by,   missing_count )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_subjects.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute missing subjects row — compute_missing_subjects","title":"Compute missing subjects row — compute_missing_subjects","text":"Counts subjects present pop_data absent target data. Uses distinct_by identify subjects; NULL, uses row-level counts.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_subjects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute missing subjects row — compute_missing_subjects","text":"","code":"compute_missing_subjects(   dt,   pop_dt,   cols,   by_data_vars,   tv,   distinct_by,   missing_label,   denom_group,   denom_dt,   fmt )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_subjects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute missing subjects row — compute_missing_subjects","text":"dt data.table target data (layer filter) pop_dt data.table population data cols Character vector spec column variable names by_data_vars Character vector -variable names data tv Character string, target variable name distinct_by Character string naming subject identifier (NULL) missing_label Character string row label denom_group Character vector denominator grouping variables denom_dt data.table denominator computation fmt f_str object formatting","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_missing_subjects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute missing subjects row — compute_missing_subjects","text":"data.table missing subjects row, NULL","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_risk_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute risk differences for count layer data — compute_risk_diff","title":"Compute risk differences for count layer data — compute_risk_diff","text":"comparison pair target variable level, computes difference proportions confidence interval using stats::prop.test().","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_risk_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute risk differences for count layer data — compute_risk_diff","text":"","code":"compute_risk_diff(counts_long, cols, tv, by_data_vars, risk_diff_config)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_risk_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute risk differences for count layer data — compute_risk_diff","text":"counts_long data.table long format n, total columns cols Character vector column variable names spec tv Character string naming target variable by_data_vars Character vector -variable names risk_diff_config List comparisons, ci, format","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_risk_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute risk differences for count layer data — compute_risk_diff","text":"data.table one row per target_var level per comparison, containing rdiff, lower, upper, p_value columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_total_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute total row — compute_total_row","title":"Compute total row — compute_total_row","text":"Compute total row","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_total_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute total row — compute_total_row","text":"","code":"compute_total_row(   counts,   dt,   cols,   by_data_vars,   tv,   total_label,   total_missings,   distinct_by,   missing_count,   denom_group,   denom_dt )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_var_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute sort key for a variable — compute_var_order","title":"Compute sort key for a variable — compute_var_order","text":"Returns integer numeric vector sort keys values variable. Priority: factor levels > VARN companion column > alphabetical. method parameter can override auto-detection.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_var_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute sort key for a variable — compute_var_order","text":"","code":"compute_var_order(   values,   var_name = NULL,   data_dt = NULL,   method = NULL,   count_values = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_var_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute sort key for a variable — compute_var_order","text":"values Character factor vector values sort var_name Character string naming variable (VARN lookup) data_dt data.table raw data (VARN lookup) method Character: NULL (auto), \"byfactor\", \"byvarn\", \"bycount\", \"alphabetical\" count_values Numeric vector counts per row (bycount method)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/compute_var_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute sort key for a variable — compute_var_order","text":"Numeric vector sort keys (lower = earlier)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/create_desc_rows_from_ard.html","id":null,"dir":"Reference","previous_headings":"","what":"Create formatted rows for desc layer from pivoted ARD stats — create_desc_rows_from_ard","title":"Create formatted rows for desc layer from pivoted ARD stats — create_desc_rows_from_ard","text":"Create formatted rows desc layer pivoted ARD stats","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/create_desc_rows_from_ard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create formatted rows for desc layer from pivoted ARD stats — create_desc_rows_from_ard","text":"","code":"create_desc_rows_from_ard(wide_stats, fmt_list, desc_group)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/custom_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a custom column group configuration — custom_group","title":"Create a custom column group configuration — custom_group","text":"Combines existing column levels custom group. Rows matching source levels duplicated column variable set group name.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/custom_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a custom column group configuration — custom_group","text":"","code":"custom_group(col_var, ...)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/custom_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a custom column group configuration — custom_group","text":"col_var Character string naming column variable ... Named arguments names group labels values character vectors source levels combine. Example: \"High Dose\" = c(\"Dose 1\", \"Dose 2\")","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/custom_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a custom column group configuration — custom_group","text":"tplyr_custom_group object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize by parameter — deserialize_by","title":"Deserialize by parameter — deserialize_by","text":"Deserialize parameter","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize by parameter — deserialize_by","text":"","code":"deserialize_by(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize expression — deserialize_expr","title":"Deserialize expression — deserialize_expr","text":"Deserialize expression","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize expression — deserialize_expr","text":"","code":"deserialize_expr(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_f_str.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize f_str from raw list — deserialize_f_str","title":"Deserialize f_str from raw list — deserialize_f_str","text":"Deserialize f_str raw list","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_f_str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize f_str from raw list — deserialize_f_str","text":"","code":"deserialize_f_str(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize a function — deserialize_function","title":"Deserialize a function — deserialize_function","text":"Deserialize function","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize a function — deserialize_function","text":"","code":"deserialize_function(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize a layer from raw list — deserialize_layer","title":"Deserialize a layer from raw list — deserialize_layer","text":"Deserialize layer raw list","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize a layer from raw list — deserialize_layer","text":"","code":"deserialize_layer(raw_layer)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Deserialize layer settings — deserialize_settings","title":"Deserialize layer settings — deserialize_settings","text":"Deserialize layer settings","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/deserialize_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deserialize layer settings — deserialize_settings","text":"","code":"deserialize_settings(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/f_str.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a format string object — f_str","title":"Create a format string object — f_str","text":"Create format string object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/f_str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a format string object — f_str","text":"","code":"f_str(format_string, ..., empty = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/f_str.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a format string object — f_str","text":"format_string Character string defining display template ... Character strings naming variables populate template empty Value(s) display data NA/missing","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/f_str.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a format string object — f_str","text":"tplyr_f_str object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_analyze_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Format analyze results using format_strings — format_analyze_results","title":"Format analyze results using format_strings — format_analyze_results","text":"group combination, takes first row numeric values analyze_fn output creates one formatted row per format_string entry.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_analyze_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format analyze results using format_strings — format_analyze_results","text":"","code":"format_analyze_results(fn_combined, format_strings, group_vars)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_analyze_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format analyze results using format_strings — format_analyze_results","text":"fn_combined data.table raw analyze_fn results format_strings Named list f_str objects group_vars Character vector grouping column names","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_analyze_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format analyze results using format_strings — format_analyze_results","text":"data.table row_label formatted columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_risk_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Format risk difference values — format_risk_diff","title":"Format risk difference values — format_risk_diff","text":"Applies f_str format computed risk difference data.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_risk_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format risk difference values — format_risk_diff","text":"","code":"format_risk_diff(rd_data, fmt)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_risk_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format risk difference values — format_risk_diff","text":"rd_data data.table rdiff, lower, upper, p_value columns fmt f_str object formatting","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_risk_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format risk difference values — format_risk_diff","text":"Character vector formatted risk difference strings","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_with_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Format values with auto-precision — format_with_precision","title":"Format values with auto-precision — format_with_precision","text":"Handles split-apply-combine precision_by creates multiple precision groups. single precision group (precision_by), resolves precision formats rows.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_with_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format values with auto-precision — format_with_precision","text":"","code":"format_with_precision(   fmt,   var_names,   stats,   group_vars,   precision_table,   precision_by )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_with_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format values with auto-precision — format_with_precision","text":"fmt f_str object var_names Character vector variable names format stats data.table computed statistics group_vars Character vector grouping column names precision_table data.table collect_precision() precision_by Character vector precision grouping variables (NULL)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/format_with_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format values with auto-precision — format_with_precision","text":"Character vector formatted values","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/generate_row_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate unique row IDs for output rows — generate_row_ids","title":"Generate unique row IDs for output rows — generate_row_ids","text":"Creates character ID row combining layer index row label values. IDs can used tplyr_meta_result() tplyr_meta_subset() look cell metadata.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/generate_row_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate unique row IDs for output rows — generate_row_ids","text":"","code":"generate_row_ids(result)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/generate_row_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate unique row IDs for output rows — generate_row_ids","text":"result data.frame produced tplyr_build()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/generate_row_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate unique row IDs for output rows — generate_row_ids","text":"Character vector row IDs (length nrow(result))","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_count_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the count format string, falling back to defaults — get_count_format","title":"Get the count format string, falling back to defaults — get_count_format","text":"Get count format string, falling back defaults","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_count_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the count format string, falling back to defaults — get_count_format","text":"","code":"get_count_format(settings)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_data_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract variable labels from a data.frame — get_data_labels","title":"Extract variable labels from a data.frame — get_data_labels","text":"Returns named character vector variable labels. Labels extracted \"label\" attribute column (standard Haven-imported CDISC data).","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_data_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract variable labels from a data.frame — get_data_labels","text":"","code":"get_data_labels(data)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_data_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract variable labels from a data.frame — get_data_labels","text":"data data.frame","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_data_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract variable labels from a data.frame — get_data_labels","text":"Named character vector names column names values labels. Columns without labels return NA_character_.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_desc_formats.html","id":null,"dir":"Reference","previous_headings":"","what":"Get descriptive format strings, falling back to defaults — get_desc_formats","title":"Get descriptive format strings, falling back to defaults — get_desc_formats","text":"Get descriptive format strings, falling back defaults","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_desc_formats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get descriptive format strings, falling back to defaults — get_desc_formats","text":"","code":"get_desc_formats(settings)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_nested_denom_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve denominator group for a nesting level — get_nested_denom_group","title":"Resolve denominator group for a nesting level — get_nested_denom_group","text":"Resolve denominator group nesting level","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/get_nested_denom_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve denominator group for a nesting level — get_nested_denom_group","text":"","code":"get_nested_denom_group(denoms_by, level, cols)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_analyze.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a custom analysis layer — group_analyze","title":"Create a custom analysis layer — group_analyze","text":"Allows user-defined function compute summary statistics. function receives data subset target variable name group combination, returns data.frame results.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_analyze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a custom analysis layer — group_analyze","text":"","code":"group_analyze(   target_var,   by = NULL,   where = NULL,   analyze_fn,   settings = layer_settings() )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_analyze.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a custom analysis layer — group_analyze","text":"target_var Character string naming target variable(s) Character string vector row grouping Expression filtering data layer analyze_fn function signature function(.data, .target_var) returns data.frame. See Details. settings layer_settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_analyze.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a custom analysis layer — group_analyze","text":"tplyr_analyze_layer object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_analyze.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a custom analysis layer — group_analyze","text":"analyze_fn called per group combination (defined cols data variables). receives: .data: data.frame subset current group .target_var: Character string target variable name(s) format_strings provided settings, analyze_fn return single-row data.frame named numeric values. format string entry becomes one output row, name used row label. format_strings provided, analyze_fn must return data.frame row_label formatted columns.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a count layer — group_count","title":"Create a count layer — group_count","text":"Create count layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a count layer — group_count","text":"","code":"group_count(target_var, by = NULL, where = NULL, settings = layer_settings())"},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a count layer — group_count","text":"target_var Character string vector naming target variable(s). Multiple variables create nested/hierarchical counts. Character string vector row grouping. Strings match column names treated text labels. Use label() explicit disambiguation. Expression filtering data layer settings layer_settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a count layer — group_count","text":"tplyr_count_layer object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_desc.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a descriptive statistics layer — group_desc","title":"Create a descriptive statistics layer — group_desc","text":"Create descriptive statistics layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_desc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a descriptive statistics layer — group_desc","text":"","code":"group_desc(target_var, by = NULL, where = NULL, settings = layer_settings())"},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_desc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a descriptive statistics layer — group_desc","text":"target_var Character string vector naming target variable(s) Character string vector row grouping Expression filtering data layer settings layer_settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_desc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a descriptive statistics layer — group_desc","text":"tplyr_desc_layer object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a shift layer — group_shift","title":"Create a shift layer — group_shift","text":"Create shift layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a shift layer — group_shift","text":"","code":"group_shift(target_var, by = NULL, where = NULL, settings = layer_settings())"},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a shift layer — group_shift","text":"target_var Named character vector row column elements Character string vector row grouping Expression filtering data layer settings layer_settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/group_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a shift layer — group_shift","text":"tplyr_shift_layer object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/harmonize_and_bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Harmonize column sets across layers and row-bind — harmonize_and_bind","title":"Harmonize column sets across layers and row-bind — harmonize_and_bind","text":"Harmonize column sets across layers row-bind","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/harmonize_and_bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Harmonize column sets across layers and row-bind — harmonize_and_bind","text":"","code":"harmonize_and_bind(layer_results)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/hug_format_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply parenthesis hugging to a format group — hug_format_group","title":"Apply parenthesis hugging to a format group — hug_format_group","text":"Shifts leading spaces formatted number trailing literal, characters like ( hug number.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/hug_format_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply parenthesis hugging to a format group — hug_format_group","text":"","code":"hug_format_group(prefix, num_part, trailing_literal)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/hug_format_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply parenthesis hugging to a format group — hug_format_group","text":"prefix Character vector accumulated result far num_part Character vector formatted numbers (leading spaces) trailing_literal Character string literal group","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/hug_format_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply parenthesis hugging to a format group — hug_format_group","text":"Character vector hugged result","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is a tplyr_label — is_label","title":"Check if an object is a tplyr_label — is_label","text":"Check object tplyr_label","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is a tplyr_label — is_label","text":"","code":"is_label(x)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is a tplyr_label — is_label","text":"x Object check","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is a tplyr_label — is_label","text":"Logical","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_pop_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is a tplyr_pop_data — is_pop_data","title":"Check if an object is a tplyr_pop_data — is_pop_data","text":"Check object tplyr_pop_data","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_pop_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is a tplyr_pop_data — is_pop_data","text":"","code":"is_pop_data(x)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_pop_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is a tplyr_pop_data — is_pop_data","text":"x object check","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_pop_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is a tplyr_pop_data — is_pop_data","text":"Logical","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is a tplyr_layer — is_tplyr_layer","title":"Check if an object is a tplyr_layer — is_tplyr_layer","text":"Check object tplyr_layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is a tplyr_layer — is_tplyr_layer","text":"","code":"is_tplyr_layer(x)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is a tplyr_layer — is_tplyr_layer","text":"x Object check","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is a tplyr_layer — is_tplyr_layer","text":"Logical","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is a tplyr_spec — is_tplyr_spec","title":"Check if an object is a tplyr_spec — is_tplyr_spec","text":"Check object tplyr_spec","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is a tplyr_spec — is_tplyr_spec","text":"","code":"is_tplyr_spec(x)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is a tplyr_spec — is_tplyr_spec","text":"x object check","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/is_tplyr_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is a tplyr_spec — is_tplyr_spec","text":"Logical","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/label.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a text label for use in by parameters — label","title":"Create a text label for use in by parameters — label","text":"Explicitly marks string text label (data variable name). Useful label string might coincidentally match column name.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a text label for use in by parameters — label","text":"","code":"label(x)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a text label for use in by parameters — label","text":"x Character string use label","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a text label for use in by parameters — label","text":"tplyr_label object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/layer_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Create layer settings — layer_settings","title":"Create layer settings — layer_settings","text":"Configuration object layer options. Unused parameters default NULL ignored build. Type-specific validation happens build time.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/layer_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create layer settings — layer_settings","text":"","code":"layer_settings(   format_strings = NULL,   denoms_by = NULL,   denom_where = NULL,   denom_ignore = NULL,   distinct_by = NULL,   indentation = \"  \",   total_row = FALSE,   total_row_label = \"Total\",   total_row_count_missings = TRUE,   missing_count = NULL,   missing_subjects = FALSE,   missing_subjects_label = \"Missing\",   keep_levels = NULL,   limit_data_by = NULL,   custom_summaries = NULL,   stats_as_columns = FALSE,   precision_by = NULL,   precision_on = NULL,   precision_data = NULL,   precision_cap = NULL,   order_count_method = NULL,   ordering_cols = NULL,   result_order_var = NULL,   outer_sort_position = NULL,   risk_diff = NULL,   name = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/layer_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create layer settings — layer_settings","text":"format_strings Named list f_str objects denoms_by Character vector variable names denominator grouping denom_where Expression separate denominator filter denom_ignore Character vector values exclude denominators distinct_by Character string naming variable distinct counting indentation Character string nested count indentation total_row Logical, whether add total row total_row_label Character string total row label total_row_count_missings Logical, include missing total missing_count List missing count configuration missing_subjects Logical, add missing subjects row missing_subjects_label Character string missing subjects label keep_levels Character vector levels keep limit_data_by Character vector data limiting custom_summaries Named list expressions custom summaries stats_as_columns Logical, transpose stats columns precision_by Character vector precision grouping precision_on Character string precision variable precision_data Data frame external precision values precision_cap Named numeric vector c(int=, dec=) order_count_method Character, ordering method ordering_cols Character, column drives ordering result_order_var Character, result variable ordering outer_sort_position Character, outer sort direction risk_diff List risk difference configuration name Character string, layer name identification","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/layer_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create layer settings — layer_settings","text":"tplyr_layer_settings object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_eq_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an equality filter expression — make_eq_filter","title":"Build an equality filter expression — make_eq_filter","text":"Build equality filter expression","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_eq_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an equality filter expression — make_eq_filter","text":"","code":"make_eq_filter(var_name, value)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_in_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an inclusion filter expression — make_in_filter","title":"Build an inclusion filter expression — make_in_filter","text":"Build inclusion filter expression","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_in_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an inclusion filter expression — make_in_filter","text":"","code":"make_in_filter(var_name, values)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_in_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build an inclusion filter expression — make_in_filter","text":"var_name Character name variable values Vector values inclusion set","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_missing_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a filter for missing values (is.na OR %in% missing_values) — make_missing_filter","title":"Build a filter for missing values (is.na OR %in% missing_values) — make_missing_filter","text":"Build filter missing values (.na %% missing_values)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_missing_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a filter for missing values (is.na OR %in% missing_values) — make_missing_filter","text":"","code":"make_missing_filter(var_name, missing_values = character(0))"},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_not_in_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an exclusion filter expression — make_not_in_filter","title":"Build an exclusion filter expression — make_not_in_filter","text":"Build exclusion filter expression","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_not_in_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an exclusion filter expression — make_not_in_filter","text":"","code":"make_not_in_filter(var_name, values)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_not_in_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build an exclusion filter expression — make_not_in_filter","text":"var_name Character name variable values Vector values exclude","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_not_na_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a !is.na() filter expression — make_not_na_filter","title":"Build a !is.na() filter expression — make_not_na_filter","text":"Build !.na() filter expression","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/make_not_na_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a !is.na() filter expression — make_not_na_filter","text":"","code":"make_not_na_filter(var_name)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/merge_risk_diff_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge risk difference columns onto wide result — merge_risk_diff_columns","title":"Merge risk difference columns onto wide result — merge_risk_diff_columns","text":"Appends formatted risk difference columns wide-format output cast_to_wide().","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/merge_risk_diff_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge risk difference columns onto wide result — merge_risk_diff_columns","text":"","code":"merge_risk_diff_columns(   wide,   rd_data,   risk_diff_config,   row_label_cols,   tv,   by_data_vars )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/merge_risk_diff_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge risk difference columns onto wide result — merge_risk_diff_columns","text":"wide data.table wide format (cast_to_wide) rd_data data.table computed risk differences risk_diff_config List comparisons, ci, format row_label_cols Character vector row label column names tv Character string naming target variable by_data_vars Character vector -variable names","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/merge_risk_diff_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge risk difference columns onto wide result — merge_risk_diff_columns","text":"Modified wide data.table rdiff columns appended","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a single format group — parse_format_group","title":"Parse a single format group — parse_format_group","text":"Parse single format group","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a single format group — parse_format_group","text":"","code":"parse_format_group(group_str)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_part.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse one side (int or dec) of a format group — parse_format_part","title":"Parse one side (int or dec) of a format group — parse_format_part","text":"Parse one side (int dec) format group","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_part.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse one side (int or dec) of a format group — parse_format_part","text":"","code":"parse_format_part(part)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a format string into groups and literals — parse_format_string","title":"Parse a format string into groups and literals — parse_format_string","text":"Parse format string groups literals","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/parse_format_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a format string into groups and literals — parse_format_string","text":"","code":"parse_format_string(fmt)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/pop_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a population data configuration — pop_data","title":"Create a population data configuration — pop_data","text":"Configuration object specifying population data maps spec. actual population data.frame provided build time via tplyr_build(spec, data, pop_data = ...).","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/pop_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a population data configuration — pop_data","text":"","code":"pop_data(cols, where = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/pop_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a population data configuration — pop_data","text":"cols Character vector column variable names population data. named, names spec column names values pop_data column names (e.g., c(\"TRTA\" = \"TRT01P\")). unnamed, maps positionally spec cols. Expression filtering population data (optional)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/pop_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a population data configuration — pop_data","text":"tplyr_pop_data object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/reconstruct_layer_from_ard.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct a single layer from ARD data — reconstruct_layer_from_ard","title":"Reconstruct a single layer from ARD data — reconstruct_layer_from_ard","text":"Reconstruct single layer ARD data","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/reconstruct_layer_from_ard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct a single layer from ARD data — reconstruct_layer_from_ard","text":"","code":"reconstruct_layer_from_ard(layer_ard, layer, cols, layer_index)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/rename_ord_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename ordering columns to match DESIGN.md convention — rename_ord_columns","title":"Rename ordering columns to match DESIGN.md convention — rename_ord_columns","text":"Renames ordindx ord_layer_index ord1/ord2/... ord_layer_1/ord_layer_2/...","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/rename_ord_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename ordering columns to match DESIGN.md convention — rename_ord_columns","text":"","code":"rename_ord_columns(result)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/rename_ord_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename ordering columns to match DESIGN.md convention — rename_ord_columns","text":"result data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/rename_ord_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename ordering columns to match DESIGN.md convention — rename_ord_columns","text":"Modified data.table (reference)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/replace_leading_whitespace.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace leading whitespace with a specified string — replace_leading_whitespace","title":"Replace leading whitespace with a specified string — replace_leading_whitespace","text":"Useful HTML rendering leading spaces collapsed.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/replace_leading_whitespace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace leading whitespace with a specified string — replace_leading_whitespace","text":"","code":"replace_leading_whitespace(x, replace_with = \" \")"},{"path":"https://github.com/mstackhouse/tplyr2/reference/replace_leading_whitespace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace leading whitespace with a specified string — replace_leading_whitespace","text":"x Character vector replace_with Replacement string leading space","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/replace_leading_whitespace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace leading whitespace with a specified string — replace_leading_whitespace","text":"Character vector leading spaces replaced","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_pop_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve population data column mapping — resolve_pop_cols","title":"Resolve population data column mapping — resolve_pop_cols","text":"Maps population data columns spec columns. Handles named (explicit) unnamed (positional) mapping.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_pop_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve population data column mapping — resolve_pop_cols","text":"","code":"resolve_pop_cols(pop_config, spec_cols)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_pop_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve population data column mapping — resolve_pop_cols","text":"pop_config tplyr_pop_data object NULL spec_cols Character vector spec-level column names","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_pop_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve population data column mapping — resolve_pop_cols","text":"Character vector column names use population data","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve auto-precision widths for a format group — resolve_precision","title":"Resolve auto-precision widths for a format group — resolve_precision","text":"Given parsed format group collected precision values, returns effective integer width decimal width.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve auto-precision widths for a format group — resolve_precision","text":"","code":"resolve_precision(group, max_int, max_dec)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve auto-precision widths for a format group — resolve_precision","text":"group parsed format group (parse_format_group) max_int Integer, collected max integer width max_dec Integer, collected max decimal precision","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/resolve_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve auto-precision widths for a format group — resolve_precision","text":"list(int_width, dec_width)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serializable_to_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert raw parsed JSON/YAML back to tplyr_spec — serializable_to_spec","title":"Convert raw parsed JSON/YAML back to tplyr_spec — serializable_to_spec","text":"Convert raw parsed JSON/YAML back tplyr_spec","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serializable_to_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert raw parsed JSON/YAML back to tplyr_spec — serializable_to_spec","text":"","code":"serializable_to_spec(raw)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize the by parameter — serialize_by","title":"Serialize the by parameter — serialize_by","text":"Serialize parameter","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize the by parameter — serialize_by","text":"","code":"serialize_by(by)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize an expression (or NULL) — serialize_expr","title":"Serialize an expression (or NULL) — serialize_expr","text":"Serialize expression (NULL)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize an expression (or NULL) — serialize_expr","text":"","code":"serialize_expr(expr)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_f_str.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize an f_str object — serialize_f_str","title":"Serialize an f_str object — serialize_f_str","text":"Serialize f_str object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_f_str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize an f_str object — serialize_f_str","text":"","code":"serialize_f_str(fmt)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize a function — serialize_function","title":"Serialize a function — serialize_function","text":"Serialize function","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize a function — serialize_function","text":"","code":"serialize_function(fn)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize a single layer — serialize_layer","title":"Serialize a single layer — serialize_layer","text":"Serialize single layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize a single layer — serialize_layer","text":"","code":"serialize_layer(layer)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize layer settings — serialize_settings","title":"Serialize layer settings — serialize_settings","text":"Serialize layer settings","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/serialize_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize layer settings — serialize_settings","text":"","code":"serialize_settings(settings)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/sort_nested.html","id":null,"dir":"Reference","previous_headings":"","what":"Sort nested count data for correct interleaving — sort_nested","title":"Sort nested count data for correct interleaving — sort_nested","text":"Sort nested count data correct interleaving","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/sort_nested.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sort nested count data for correct interleaving — sort_nested","text":"","code":"sort_nested(combined, target_vars, by_data_vars)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/spec_to_serializable.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert spec to a plain list suitable for JSON/YAML — spec_to_serializable","title":"Convert spec to a plain list suitable for JSON/YAML — spec_to_serializable","text":"Convert spec plain list suitable JSON/YAML","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/spec_to_serializable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert spec to a plain list suitable for JSON/YAML — spec_to_serializable","text":"","code":"spec_to_serializable(spec)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_extract_num.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract numeric values from formatted strings — str_extract_num","title":"Extract numeric values from formatted strings — str_extract_num","text":"Extracts Nth numeric value formatted tplyr2 string.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_extract_num.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract numeric values from formatted strings — str_extract_num","text":"","code":"str_extract_num(x, index = 1L)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_extract_num.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract numeric values from formatted strings — str_extract_num","text":"x Character vector formatted strings index Integer, numeric value extract (1-based)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_extract_num.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract numeric values from formatted strings — str_extract_num","text":"Numeric vector","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"Leverages stringr::str_wrap() hood, takes extra steps preserve indentation applied character element, use hyphenated wrapping single words run longer allotted wrapping width.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"","code":"str_indent_wrap(x, width = 10, tab_width = 5)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"x input character vector width desired width elements within output character vector tab_width number spaces tabs converted","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"character vector string wrapping applied","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"stringr::str_wrap() highly efficient, context table creation two features missing — hyphenation long running strings overflow width, respect pre-indentation character element. example, adverse event table, may body system rows un-indented column, preferred terms indented columns. strings may run long require wrapping surpass column width. Furthermore, crowded tables single word may longer column width . function resolves two issues, minimizing additional overhead required apply wrapping strings. Note: function automatically converts tabs spaces. Tab width varies depending font, width automatically determined within data frame. Users can specify width via tab_width.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/str_indent_wrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap strings to a specific width with hyphenation while preserving indentation — str_indent_wrap","text":"","code":"ex_text1 <- c(\"RENAL AND URINARY DISORDERS\", \"   NEPHROLITHIASIS\") ex_text2 <- c(\"RENAL AND URINARY DISORDERS\", \"\\tNEPHROLITHIASIS\")  cat(paste(str_indent_wrap(ex_text1, width = 8), collapse = \"\\n\\n\"), \"\\n\") #> RENAL #> AND #> URINARY #> DISORDE- #> RS #>  #>    NEPHROL- #>    ITHIASI- #>    S  cat(paste(str_indent_wrap(ex_text2, tab_width = 4), collapse = \"\\n\\n\"), \"\\n\") #> RENAL AND #> URINARY #> DISORDERS #>  #>     NEPHROLIT- #>     HIASIS"},{"path":"https://github.com/mstackhouse/tplyr2/reference/total_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a total group configuration — total_group","title":"Create a total group configuration — total_group","text":"Specifies synthetic \"Total\" column level added duplicating rows specified column variable set label.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/total_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a total group configuration — total_group","text":"","code":"total_group(col_var, label = \"Total\")"},{"path":"https://github.com/mstackhouse/tplyr2/reference/total_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a total group configuration — total_group","text":"col_var Character string naming column variable totalize label Character string total group label (default: \"Total\")","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/total_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a total group configuration — total_group","text":"tplyr_total_group object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"tplyr2: A Grammar of Clinical Summary Tables — tplyr2-package","title":"tplyr2: A Grammar of Clinical Summary Tables — tplyr2-package","text":"Implements grammar summary data clinical reports. Clinical summary tables decomposed modular layers, representing independent summary block. Supports count, descriptive statistics, shift layer types declarative spec-based API built data.table performance.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"tplyr2: A Grammar of Clinical Summary Tables — tplyr2-package","text":"Maintainer: Mike Stackhouse mike.stackhouse@atorusresearch.com","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set tplyr2 package options — tplyr2_options","title":"Get or set tplyr2 package options — tplyr2_options","text":"View modify tplyr2-specific options. called arguments, returns current tplyr2 options defaults. called named arguments, sets options.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set tplyr2 package options — tplyr2_options","text":"","code":"tplyr2_options(...)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set tplyr2 package options — tplyr2_options","text":"... Named arguments set (e.g., IBMRounding = TRUE). Option names automatically prefixed tplyr2..","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set tplyr2 package options — tplyr2_options","text":"called arguments, named list current option values. called arguments, invisibly returns previous values.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr2_options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set tplyr2 package options — tplyr2_options","text":"Available options: tplyr2.IBMRounding Logical. Use round-half-away--zero instead R's default banker's rounding. Default: FALSE. tplyr2.quantile_type Integer. Quantile algorithm type passed quantile(). Default: 7. tplyr2.precision_cap Named numeric vector c(int=, dec=). Maximum int/dec widths auto-precision. Default: NULL. tplyr2.custom_summaries Named list expressions global custom summary functions. Default: NULL. tplyr2.scipen Integer. scipen value used tplyr_build() prevent scientific notation. Default: 9999.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adae.html","id":null,"dir":"Reference","previous_headings":"","what":"Adverse events analysis dataset — tplyr_adae","title":"Adverse events analysis dataset — tplyr_adae","text":"sample CDISC ADaM ADAE dataset PHUSE Test Data Factory. Contains adverse event records.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adae.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adverse events analysis dataset — tplyr_adae","text":"","code":"tplyr_adae"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adae.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Adverse events analysis dataset — tplyr_adae","text":"data.frame","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adlb.html","id":null,"dir":"Reference","previous_headings":"","what":"Laboratory data analysis dataset — tplyr_adlb","title":"Laboratory data analysis dataset — tplyr_adlb","text":"sample CDISC ADaM ADLB dataset PHUSE Test Data Factory. Contains laboratory test results.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adlb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Laboratory data analysis dataset — tplyr_adlb","text":"","code":"tplyr_adlb"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adlb.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Laboratory data analysis dataset — tplyr_adlb","text":"data.frame","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adsl.html","id":null,"dir":"Reference","previous_headings":"","what":"Subject-level analysis dataset — tplyr_adsl","title":"Subject-level analysis dataset — tplyr_adsl","text":"sample CDISC ADaM ADSL dataset PHUSE Test Data Factory. Contains subject-level demographics baseline characteristics.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adsl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subject-level analysis dataset — tplyr_adsl","text":"","code":"tplyr_adsl"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_adsl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Subject-level analysis dataset — tplyr_adsl","text":"data.frame","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_build.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a tplyr2 table from a spec and data — tplyr_build","title":"Build a tplyr2 table from a spec and data — tplyr_build","text":"Executes table specification provided data, producing formatted output data frame.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a tplyr2 table from a spec and data — tplyr_build","text":"","code":"tplyr_build(spec, data, pop_data = NULL, metadata = FALSE, ...)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a tplyr2 table from a spec and data — tplyr_build","text":"spec tplyr_spec object (path JSON/YAML spec file) data data.frame process pop_data Optional population data.frame (overrides spec pop_data) metadata TRUE, attach cell-level metadata enabling traceability back source data rows via tplyr_meta_result() tplyr_meta_subset(). ... Additional named arguments override spec-level parameters","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_build.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a tplyr2 table from a spec and data — tplyr_build","text":"data.frame rowlabel, res, ord columns","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_from_ard.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct a formatted table from ARD and a spec — tplyr_from_ard","title":"Reconstruct a formatted table from ARD and a spec — tplyr_from_ard","text":"Takes Analysis Results Data (long format) tplyr_spec, applies spec's formatting rules produce formatted output table.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_from_ard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct a formatted table from ARD and a spec — tplyr_from_ard","text":"","code":"tplyr_from_ard(ard, spec)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_from_ard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct a formatted table from ARD and a spec — tplyr_from_ard","text":"ard data.frame ARD format (produced tplyr_to_ard()) spec tplyr_spec object defining table structure","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_from_ard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct a formatted table from ARD and a spec — tplyr_from_ard","text":"data.frame structure tplyr_build() output","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_header_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract header N from a tplyr2 build result — tplyr_header_n","title":"Extract header N from a tplyr2 build result — tplyr_header_n","text":"Returns population-based header N values computed tplyr_build(). available population data provided.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_header_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract header N from a tplyr2 build result — tplyr_header_n","text":"","code":"tplyr_header_n(result)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_header_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract header N from a tplyr2 build result — tplyr_header_n","text":"result data.frame produced tplyr_build()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_header_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract header N from a tplyr2 build result — tplyr_header_n","text":"data.frame column variable levels N values, NULL population data used.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_layers.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of layers — tplyr_layers","title":"Create a list of layers — tplyr_layers","text":"Wraps one layer objects validated list use tplyr_spec().","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_layers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of layers — tplyr_layers","text":"","code":"tplyr_layers(...)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_layers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of layers — tplyr_layers","text":"... Layer objects created group_count(), group_desc(), group_shift(), group_analyze()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_layers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list of layers — tplyr_layers","text":"list tplyr_layer objects","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta.html","id":null,"dir":"Reference","previous_headings":"","what":"Metadata object for a tplyr output cell — tplyr_meta","title":"Metadata object for a tplyr output cell — tplyr_meta","text":"Contains filter expressions , evaluated original data, reproduce subset rows contributed specific cell output table.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metadata object for a tplyr output cell — tplyr_meta","text":"","code":"tplyr_meta(   names = character(0),   filters = list(),   layer_index = integer(0),   anti_join = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metadata object for a tplyr output cell — tplyr_meta","text":"names Character vector variable names relevant cell filters List R language objects (call expressions) representing filter conditions layer_index Integer layer index (1-based) anti_join NULL tplyr_meta_anti_join object missing subjects rows","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metadata object for a tplyr output cell — tplyr_meta","text":"tplyr_meta object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_anti_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Anti-join metadata for missing subjects — tplyr_meta_anti_join","title":"Anti-join metadata for missing subjects — tplyr_meta_anti_join","text":"Anti-join metadata missing subjects","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_anti_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anti-join metadata for missing subjects — tplyr_meta_anti_join","text":"","code":"tplyr_meta_anti_join(join_meta, on)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_anti_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anti-join metadata for missing subjects — tplyr_meta_anti_join","text":"join_meta tplyr_meta object filters population data Character vector join key variable names (e.g., \"USUBJID\")","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_anti_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anti-join metadata for missing subjects — tplyr_meta_anti_join","text":"tplyr_meta_anti_join object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Get metadata for a specific output cell — tplyr_meta_result","title":"Get metadata for a specific output cell — tplyr_meta_result","text":"Returns tplyr_meta object containing filter expressions describe source data specified cell.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get metadata for a specific output cell — tplyr_meta_result","text":"","code":"tplyr_meta_result(result, row_id, column)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get metadata for a specific output cell — tplyr_meta_result","text":"result data.frame tplyr_build() built metadata = TRUE row_id Character row ID (result$row_id generate_row_ids()) column Character column name (e.g., \"res1\")","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get metadata for a specific output cell — tplyr_meta_result","text":"tplyr_meta object, NULL metadata cell","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Get source data rows for a specific output cell — tplyr_meta_subset","title":"Get source data rows for a specific output cell — tplyr_meta_subset","text":"Evaluates stored filter expressions original data return rows contributed specified output cell.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get source data rows for a specific output cell — tplyr_meta_subset","text":"","code":"tplyr_meta_subset(result, row_id, column, data, pop_data = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get source data rows for a specific output cell — tplyr_meta_subset","text":"result data.frame tplyr_build() built metadata = TRUE row_id Character row ID column Character column name (e.g., \"res1\") data original data.frame passed tplyr_build() pop_data Optional population data.frame, required cell represents missing subjects row (anti-join)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_meta_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get source data rows for a specific output cell — tplyr_meta_subset","text":"data.frame subset original data, NULL metadata","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_numeric_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve raw numeric data from a tplyr_build result — tplyr_numeric_data","title":"Retrieve raw numeric data from a tplyr_build result — tplyr_numeric_data","text":"Returns unformatted numeric data computed build process, formatting pivoting wide format.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_numeric_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve raw numeric data from a tplyr_build result — tplyr_numeric_data","text":"","code":"tplyr_numeric_data(result, layer = NULL)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_numeric_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve raw numeric data from a tplyr_build result — tplyr_numeric_data","text":"result data.frame produced tplyr_build() layer Integer layer index (1-based), NULL layers","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_numeric_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve raw numeric data from a tplyr_build result — tplyr_numeric_data","text":"layer specified, data.frame raw statistics layer. layer NULL, named list data.frames keyed layer index. Returns NULL numeric data retained.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_read_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a tplyr_spec from JSON or YAML — tplyr_read_spec","title":"Read a tplyr_spec from JSON or YAML — tplyr_read_spec","text":"Deserializes spec file. Expressions reconstructed string representations.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_read_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a tplyr_spec from JSON or YAML — tplyr_read_spec","text":"","code":"tplyr_read_spec(path)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_read_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a tplyr_spec from JSON or YAML — tplyr_read_spec","text":"path File path JSON YAML spec file","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_read_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a tplyr_spec from JSON or YAML — tplyr_read_spec","text":"tplyr_spec object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_round.html","id":null,"dir":"Reference","previous_headings":"","what":"Round numbers with optional IBM rounding — tplyr_round","title":"Round numbers with optional IBM rounding — tplyr_round","text":"getOption(\"tplyr2.IBMRounding\", FALSE) TRUE, uses round-half-away--zero (IBM convention) instead R's default banker's rounding (round half even).","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_round.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Round numbers with optional IBM rounding — tplyr_round","text":"","code":"tplyr_round(x, digits = 0)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_round.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Round numbers with optional IBM rounding — tplyr_round","text":"x Numeric vector digits Number decimal places","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_round.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Round numbers with optional IBM rounding — tplyr_round","text":"Numeric vector","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a tplyr2 table specification — tplyr_spec","title":"Create a tplyr2 table specification — tplyr_spec","text":"spec pure configuration object describing compute. data processing occurs tplyr_build() called.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a tplyr2 table specification — tplyr_spec","text":"","code":"tplyr_spec(   cols,   where = NULL,   pop_data = NULL,   total_groups = NULL,   custom_groups = NULL,   layers = tplyr_layers(),   settings = NULL )"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a tplyr2 table specification — tplyr_spec","text":"cols Character vector column variable names Expression global data filter (optional) pop_data pop_data() object population-based features (optional) total_groups List total_group() objects (optional) custom_groups List custom_group() objects (optional) layers list layer objects tplyr_layers() settings Additional spec-level settings (optional)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a tplyr2 table specification — tplyr_spec","text":"tplyr_spec object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_stats_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve raw statistic values from a tplyr_build result — tplyr_stats_data","title":"Retrieve raw statistic values from a tplyr_build result — tplyr_stats_data","text":"Filters raw numeric data specific layer statistic.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_stats_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve raw statistic values from a tplyr_build result — tplyr_stats_data","text":"","code":"tplyr_stats_data(result, layer, statistic)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_stats_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve raw statistic values from a tplyr_build result — tplyr_stats_data","text":"result data.frame produced tplyr_build() layer Integer layer index (1-based) statistic Character string naming statistic column extract (e.g., \"n\", \"pct\", \"mean\", \"sd\")","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_stats_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve raw statistic values from a tplyr_build result — tplyr_stats_data","text":"data.frame grouping columns requested statistic. Returns NULL available.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_to_ard.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert tplyr_build output to Analysis Results Data (ARD) format — tplyr_to_ard","title":"Convert tplyr_build output to Analysis Results Data (ARD) format — tplyr_to_ard","text":"Transforms numeric data attached tplyr_build() result long-format data frame one row per statistic per group combination. compatible CDISC Analysis Results Data standard.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_to_ard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert tplyr_build output to Analysis Results Data (ARD) format — tplyr_to_ard","text":"","code":"tplyr_to_ard(result)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_to_ard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert tplyr_build output to Analysis Results Data (ARD) format — tplyr_to_ard","text":"result data.frame produced tplyr_build()","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_to_ard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert tplyr_build output to Analysis Results Data (ARD) format — tplyr_to_ard","text":"data.frame long format columns: analysis_id Integer layer index stat_name Character name statistic stat_value Numeric value statistic ... Grouping columns original data","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_write_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","title":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","text":"Serializes spec object file. format determined file extension: .json JSON, .yaml .yml YAML.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_write_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","text":"","code":"tplyr_write_spec(spec, path)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_write_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","text":"spec tplyr_spec object path File path. Extension determines format.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_write_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","text":"Invisible file path","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/tplyr_write_spec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write a tplyr_spec to JSON or YAML — tplyr_write_spec","text":"Expressions (e.g., clauses) deparsed strings reconstructed read. Format string objects (f_str) stored component parts regenerated read.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/translate_group_value.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate a group value to filter expressions — translate_group_value","title":"Translate a group value to filter expressions — translate_group_value","text":"column value corresponds total group custom group label, translates back appropriate filter. Total groups produce filter (values pass). Custom groups produce %% filter component values.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/translate_group_value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate a group value to filter expressions — translate_group_value","text":"","code":"translate_group_value(value, col_var, total_groups, custom_groups)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/translate_group_value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate a group value to filter expressions — translate_group_value","text":"value column value output (e.g., \"Total\", \"Active\") col_var column variable name total_groups List tplyr_total_group objects custom_groups List tplyr_custom_group objects","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/translate_group_value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate a group value to filter expressions — translate_group_value","text":"list filters (list call expressions) is_total (logical)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/transpose_stats_to_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose stats-as-columns — transpose_stats_to_columns","title":"Transpose stats-as-columns — transpose_stats_to_columns","text":"Transposes standard wide output treatment groups become rows stat names become columns.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/transpose_stats_to_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose stats-as-columns — transpose_stats_to_columns","text":"","code":"transpose_stats_to_columns(wide)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/transpose_stats_to_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose stats-as-columns — transpose_stats_to_columns","text":"wide data.table standard desc processing","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/transpose_stats_to_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose stats-as-columns — transpose_stats_to_columns","text":"Transposed data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_build_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate data compatibility at build time — validate_build_data","title":"Validate data compatibility at build time — validate_build_data","text":"Checks columns referenced spec actually exist data. Called data conversion data.table.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_build_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate data compatibility at build time — validate_build_data","text":"","code":"validate_build_data(spec, dt)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_build_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate data compatibility at build time — validate_build_data","text":"spec tplyr_spec object dt data.table","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_build_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate data compatibility at build time — validate_build_data","text":"Invisible TRUE valid","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_format_strings.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate format strings in layer settings — validate_format_strings","title":"Validate format strings in layer settings — validate_format_strings","text":"Validate format strings layer settings","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_format_strings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate format strings in layer settings — validate_format_strings","text":"","code":"validate_format_strings(fmt_list, layer_index)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_format_strings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate format strings in layer settings — validate_format_strings","text":"fmt_list named list expected contain f_str objects layer_index Integer layer index (error messages)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_format_strings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate format strings in layer settings — validate_format_strings","text":"Invisible TRUE valid","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a single layer — validate_layer","title":"Validate a single layer — validate_layer","text":"Validate single layer","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a single layer — validate_layer","text":"","code":"validate_layer(layer, index)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a single layer — validate_layer","text":"layer tplyr_layer object index Integer layer index (error messages)","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a single layer — validate_layer","text":"Invisible TRUE valid","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate that format string vars are valid stats for the layer type — validate_layer_stats","title":"Validate that format string vars are valid stats for the layer type — validate_layer_stats","text":"Issues warnings (errors) unrecognized statistic names, since custom summaries can add arbitrary stat names.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate that format string vars are valid stats for the layer type — validate_layer_stats","text":"","code":"validate_layer_stats(layer, index)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate that format string vars are valid stats for the layer type — validate_layer_stats","text":"layer tplyr_layer object index Integer layer index","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_layer_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate that format string vars are valid stats for the layer type — validate_layer_stats","text":"Invisible TRUE","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate a tplyr_spec object structurally — validate_spec","title":"Validate a tplyr_spec object structurally — validate_spec","text":"Checks spec correct class structure. Called overrides applied data processed.","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate a tplyr_spec object structurally — validate_spec","text":"","code":"validate_spec(spec)"},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate a tplyr_spec object structurally — validate_spec","text":"spec tplyr_spec object","code":""},{"path":"https://github.com/mstackhouse/tplyr2/reference/validate_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate a tplyr_spec object structurally — validate_spec","text":"Invisible TRUE valid, otherwise stops informative error","code":""}]
